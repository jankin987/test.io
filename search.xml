<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CGACD</title>
      <link href="/2020/08/06/cgacd/"/>
      <url>/2020/08/06/cgacd/</url>
      
        <content type="html"><![CDATA[<h1 id="correlation-guided-attention-for-corner-detection-based-visual-trackingcgacd"><a class="markdownIt-Anchor" href="#correlation-guided-attention-for-corner-detection-based-visual-trackingcgacd"></a> Correlation-Guided Attention for Corner Detection Based Visual Tracking【CGACD】</h1><blockquote><p><img src="/2020/08/06/cgacd/image-20200804152612249.png" alt="image-20200804152612249"></p><p>📄 paper: <a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Du_Correlation-Guided_Attention_for_Corner_Detection_Based_Visual_Tracking_CVPR_2020_paper.pdf">https://openaccess.thecvf.com/content_CVPR_2020/papers/Du_Correlation-Guided_Attention_for_Corner_Detection_Based_Visual_Tracking_CVPR_2020_paper.pdf</a></p><p>supp: <a href="https://openaccess.thecvf.com/content_CVPR_2020/supplemental/Du_Correlation-Guided_Attention_for_CVPR_2020_supplemental.pdf">https://openaccess.thecvf.com/content_CVPR_2020/supplemental/Du_Correlation-Guided_Attention_for_CVPR_2020_supplemental.pdf</a></p><p>📹 video: <a href="https://www.youtube.com/watch?v=GXsiMpAWr4k">https://www.youtube.com/watch?v=GXsiMpAWr4k</a></p><p>💻 code:  <a href="https://github.com/ohhhyeahhh/SiamCAR">https://github.com/ohhhyeahhh/SiamCAR</a></p><p>🌟  CVPR 2020</p></blockquote><a id="more"></a><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> <strong>Abstract</strong></h1><p>​相关性指导的注意力 + corner的anchor-free检测</p><p>（注意力机制 + anchor-free机制）</p><p>​<strong>two-stage method</strong></p><p>​(1). extract RoI by Siamese network</p><p>​(2). pixel-wise correlation-guided spatial attention module</p><p>​<strong>speed:</strong> running at 70FPS</p><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p><strong>Several limitations</strong> on existing Corner detection-based tracking：</p><ul><li>directly detect corners，difficulty distinguishing distractors and target from the crones.</li><li>not effectively explore the relationship between the template and the search image, spatial information about the corners not  explicitly encoded in the correlation results.</li><li>not use powerful networks. (like ResNet)</li></ul><p><strong>Key innovation:</strong></p><ul><li>exploit the relationship between template and RoI.</li><li><strong>pixel-wise correlation</strong> to calculate the similarity between each template feature maps and RoI feature maps. (encode spatial information)</li><li><strong>channel-wise correlation</strong> to calculate the channel-wise similarity maps. (encode importance information of the various channels)</li></ul><h1 id="2-network-architecture"><a class="markdownIt-Anchor" href="#2-network-architecture"></a> 2. Network Architecture</h1><p><img src="/2020/08/06/cgacd/image-20200805110457598.png" alt="image-20200805110457598"></p><ul><li><p>max-pooling and average-pooling gather different  clues about the channel importance.</p></li><li><p>Unlike traditional cross-correlation, pixel-wise correlation separately highlights different parts of the target in different similarity maps.</p></li><li><p>the hourglass-structure network learns spatial attention maps from the pixel-wise similarity maps, which adaptively attend to the top-left and botom-right  corners.</p></li><li><p>Upsample: conv + nearest interpolation</p></li></ul><h1 id="3-experiments"><a class="markdownIt-Anchor" href="#3-experiments"></a> 3. Experiments</h1><h2 id="31-method-analysis"><a class="markdownIt-Anchor" href="#31-method-analysis"></a> 3.1 Method Analysis</h2><ul><li><p><strong>exploitation of relationship</strong></p><p>comparison of different integrating template and search image approaches (PS / AUC on OTB2015 &amp; UAV123)</p><p><img src="/2020/08/06/cgacd/image-20200806112851440.png" alt="image-20200806112851440"></p></li><li><p><strong>structure of attention module</strong></p><p>cross-correlation vs. guide spatial and channel attention.  see⬆️</p></li><li><p><strong>siamese tracking module</strong></p><p>show the effectiveness croner detection module (↑4.0% in PS &amp; ↑4.8% in AUC )</p><p><img src="/2020/08/06/cgacd/image-20200806152944256.png" alt="image-20200806152944256"></p></li><li><p><strong>feature from different layers</strong></p><p>compare performance from different layers of the backbone.</p><p>(conv4 block is best!)</p><p><img src="/2020/08/06/cgacd/image-20200806112938480.png" alt="image-20200806112938480"></p></li><li><p><strong>Impact of RoI augmentation</strong></p><p>(↑0.5% in PS &amp; ↑0.5% in AUC )  see ⬆️</p></li></ul><h2 id="32-sota-comparison"><a class="markdownIt-Anchor" href="#32-sota-comparison"></a> 3.2 SOTA comparison</h2><ul><li><p>VOT2018</p><p><img src="/2020/08/06/cgacd/image-20200806113427292.png" alt="image-20200806113427292"></p></li><li><p>OTB2015</p><p><img src="/2020/08/06/cgacd/image-20200806113442294.png" alt="image-20200806113442294"></p></li><li><p>UAV123</p><p><img src="/2020/08/06/cgacd/image-20200806113506461.png" alt="image-20200806113506461"></p></li><li><p>LaSOT</p><p><img src="/2020/08/06/cgacd/image-20200806113601298.png" alt="image-20200806113601298"></p></li><li><p>TrackingNet</p><p><img src="/2020/08/06/cgacd/image-20200806113622285.png" alt="image-20200806113622285"></p></li></ul><h1 id="4-supplementary-material"><a class="markdownIt-Anchor" href="#4-supplementary-material"></a> 4. Supplementary Material</h1><p><img src="/2020/08/06/cgacd/image-20200806153106384.png" alt="image-20200806153106384"></p><p><img src="/2020/08/06/cgacd/image-20200806153208698.png" alt="image-20200806153208698"></p>]]></content>
      
      
      <categories>
          
          <category> Attention </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SiamRPN++</title>
      <link href="/2020/07/05/siamrpn/"/>
      <url>/2020/07/05/siamrpn/</url>
      
        <content type="html"><![CDATA[<h1 id="siamrpn-evolution-of-siamese-visual-tracking-with-very-deep-networks"><a class="markdownIt-Anchor" href="#siamrpn-evolution-of-siamese-visual-tracking-with-very-deep-networks"></a> SiamRPN++: Evolution of Siamese Visual Tracking with Very Deep Networks</h1><blockquote><p><img src="/2020/07/05/siamrpn/image-20200629142634296.png" alt="image-20200629142634296"></p><p>📄 paper: <a href="https://arxiv.org/pdf/1812.11703.pdf">https://arxiv.org/pdf/1812.11703.pdf</a></p><p>💻 code: <a href="https://github.com/STVIR/pysot">https://github.com/STVIR/pysot</a></p><p>🌟  CVPR 2019 oral</p></blockquote><a id="more"></a><h1 id="1-siamrpn回顾"><a class="markdownIt-Anchor" href="#1-siamrpn回顾"></a> 1. SiamRPN回顾</h1><ul><li>基于 SiamFC, 引入了 Faster RCNN 中的 RPN 模块，让 tracker 可以回归位置、形状，可以省掉多尺度测试，提高算法性能的同时算法的跟踪速度；</li><li>使用更大的数据集 VID 和 Youtube-BB 来进行跟踪网络的训练</li></ul><p><img src="/2020/07/05/siamrpn/image-20200702160817501.png" alt="image-20200702160817501"></p><p>correlation 操作详解（涉及到后续改进）：</p><ul><li><p>以分类分支为例，在 RPN 中，分类分支需要输出一个通道数为 2k 的特征图（ k 为 anchor 个数），SiamFC 中使用的 correlation 只能提供通道数为 1 的响应图，无法满足要求。</p></li><li><p>SiamRPN把 correlation 层当成一个卷积层，template 分支提取的特征作为卷积核，detection 分支提取的特征作为卷积层的 input，这样只需要改变卷积核的形状就可以达到输出 2k 通道数的目的。</p></li><li><p>具体做法为使用了两个不同的卷积层，template 分支的卷积层负责升维，把通道数提升到 256*2k ，为了保持对齐，detection 分支也增加了一个卷积层，不过保持通道数不变。之后进行 correlation 操作（卷积），得到最终的分类结果。</p></li></ul><p><strong>动机：</strong></p><p>​该论文主要解决的问题是将深层基准网络 ResNet、Inception 等网络应用到基于孪生网络的跟踪网络中。在 SiameseFC 算法之后，尽管已经有很多的基于孪生网络的跟踪算法，但是这些网络都使用浅层的类 AlexNet 做为基准特征提取器。其实在这之前，也有学者们尝试着使用深层的网络，但是发现直接使用预训练好的深层网络反而会导致跟踪算法精度的下降，因此，这成为了一个基于孪生网络的跟踪器需要解决的一个关键问题！</p><h1 id="2-缓解平移不变性问题"><a class="markdownIt-Anchor" href="#2-缓解平移不变性问题"></a> 2. 缓解平移不变性问题</h1><h2 id="21-siamfc的限制"><a class="markdownIt-Anchor" href="#21-siamfc的限制"></a> 2.1 SiamFC的限制</h2><p>​SiamFC的相关操作可以看成是按照滑窗的形式计算每个位置的相似度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>ϕ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(z,x)=\phi(z)*\phi(x)+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϕ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，这就会带来两个限制：</p><ul><li><strong>网络需要满足严格的平移不变性</strong>。如 SiamFC 中介绍的，padding 会破坏这种性质，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Δ</mi><msub><mi>τ</mi><mi>j</mi></msub></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Δ</mi><msub><mi>τ</mi><mi>j</mi></msub></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f(z, x[\Delta_{\tau_j}])=f(z,x)[\Delta_{\tau_j}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0973199999999999em;vertical-align:-0.34731999999999996em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.1132em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0973199999999999em;vertical-align:-0.34731999999999996em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mopen">[</span><span class="mord"><span class="mord">Δ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.1132em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>；</li><li><strong>网络具有对称性</strong>，即如果将搜索区域图像和模板区域图像进行互换，输出的结果应该保持不变。（因为是相似度，所以应该有对称性）， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>z</mi><mo separator="true">,</mo><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><msup><mi>x</mi><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup></msup><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(z, x^{&#x27;})=f(x^{&#x27;}, z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.19248em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.19248em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.94248em;"><span style="top:-2.94248em;margin-right:0.05em;"><span class="pstrut" style="height:2.57948em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278285714285715em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>。</li></ul><h2 id="22-分析"><a class="markdownIt-Anchor" href="#22-分析"></a> 2.2 分析</h2><ul><li><p><strong>现代化网络</strong></p><p>​随着何铠明等提出残差网络以后，网络的深度得到了巨大的释放，通常物体检测和语义分割的 baseline backbone 都采用 ResNet50 的结构。为了保证网络具有适当 / 整齐的分辨率，几乎所有的现代网络 backbone 都需要执行 padding 操作。<br>​而 ResNet 网络中具有 padding 操作，即该网络肯定不具备严格的平移不变性，padding 的引入会使得网络输出的响应对不同位置有了不同的认知。而我们进行进一步的训练是希望网络学习到如何通过物体的表观特征来分辨回归物体，这就限制了深网络在 tracking 领域的应用。</p></li><li><p><strong>网络对称性</strong></p><p>​由于 SiamRPN 不再是进行相似度计算，而是通过计算回归的偏移量和分类的分数来选择最终的目标，这将使得该网络不再具有对称性。因而在 SiamRPN 的改进中需要引入非对称的部件，如果完全 Siamese的话没法达到目的，这一点主要会引导后面的 correlation设计。</p></li></ul><h2 id="23-解决"><a class="markdownIt-Anchor" href="#23-解决"></a> 2.3 解决</h2><p>​如果使用现代化网络，平移不变性被破坏以后，带来的弊端就是会学习到<strong>位置偏见</strong>（spatial bias）。由于SiamFC 的训练方法是正样本都在正中心，网络逐渐会学习到这种统计特性，学到样本中正样本分布的情况。</p><p>​简而言之，网络会给图像的中心位置分配更大的权重。</p><p>​</p><p><strong>使用shift操作增强数据：</strong></p><p><img src="/2020/07/05/siamrpn/image-20200702161914523.png" alt="image-20200702161914523"></p><p>​可以看到，只是简单地在数据增强上加了一步shift操作，就可以一定程度上缓解位置偏见的问题。</p><p><strong>实验验证：</strong></p><p><img src="/2020/07/05/siamrpn/image-20200702162811365.png" alt="image-20200702162811365"></p><p>​当我们像 SiamFC 一样训练，即把正样本都放在图像中心时，网络只会对图像中心产生响应；如果我们把正样本均匀分布到某个范围内，而不是一直在中心时（所谓的范围即是指距离中心点一定距离，该距离为 shift；正样本在这个范围内是均匀分布的），随着 shift 的不断增大，这种现象能够逐渐得到缓解。</p><p>​图中当 shift 从 0 变化到 64 的时候，跟踪算法在 VOT2016 和 VOT2018 上的效果都有了显著的性能提升，当 shift 超过 64 之后，提升的性能并不大，这可以从一方面说明该操作可以在一定程度上缓解上述这个问题。</p><h2 id="24-检测分割中为什么可行"><a class="markdownIt-Anchor" href="#24-检测分割中为什么可行"></a> 2.4 检测&amp;分割中为什么可行？</h2><p>​因为对于物体检测和语义分割而言，训练过程中，物体本身就是在全图的每个位置较为均匀的分布。</p><p>​我们可以很容易的验证，如果在物体检测网络只训练标注在图像中心的样本，而边缘的样本都不进行训练，那么显然，这样训练的网络只会对图像的中心位置产生高响应，边缘位置就随缘了，不难想象这种时候边缘位置的性能显然会大幅衰减。</p><p>​更为致命的是，按照 SiamFC 的训练方式，中心位置为正样本，边缘位置为负样本。那么网络只会记录下边缘永远为负，不管表观是什么样子了。这完全背离了我们训练的初衷。</p><h1 id="3-使用深层网络"><a class="markdownIt-Anchor" href="#3-使用深层网络"></a> 3. 使用深层网络</h1><p><img src="/2020/07/05/siamrpn/image-20200702163155149.png" alt="image-20200702163155149"></p><p>​文中实验主要在ResNet-50上进行，由于现代化网络一般都是 stride为32，但跟踪为了定位的准确性，一般 stride 需要比较小（Siamese 系列一般都为 8），所以我们<strong>把 ResNet 最后两个 block 的 stride 去掉，同时增加了 dilated convolution，一是为了增加感受野，二是为了能利用上预训练参数</strong>。论文中提到的 MobileNet 等其他网络也是进行了这样的改动。如上图所示，改过之后，后面三个 block 的分辨率就一致了。</p><p>​在训练过程中采用了新的采样策略后，我们可以训练 ResNet 网络了，并且能够正常跟踪一些视频了。（之前跟踪过程中一直聚集在中心，根本无法正常跟踪目标）。对 backbone 进行 finetune 以后，又能够进一步得到一些性能提升。</p><h1 id="4-多层特征融合"><a class="markdownIt-Anchor" href="#4-多层特征融合"></a> 4. 多层特征融合</h1><p>​由于深层网络中的层数比较多，网络的不同 block 块能够获取的特征也具有很大的差别，浅层网络特征更关注于提取一些颜色、边缘等信息，而深层网络特征则更关注于目标的语义特征，因此将深层网络的多层特征进行融合是一个值得研究的工作。</p><p>​论文中选择了网络最后三个 block 的输出进行融合（由于之前对网络的改动，所以分辨率一致，融合时实现起来简单）。对于融合方式上论文并没有做过多的探究，直接做了线性加权。其实，如何做加权也是一个值得研究的事情，本文并没有在这里深究，这里可以进行更加深入的研究。</p><blockquote><p>UPDT中就是对浅层特征和深层特征做了自适应权重的融合，取得了比较好的效果。（ECCV 2018）</p></blockquote><p><img src="/2020/07/05/siamrpn/image-20200702163657358.png" alt="image-20200702163657358"></p><h1 id="5-depthwise-cross-correlation深度网络通用的改进"><a class="markdownIt-Anchor" href="#5-depthwise-cross-correlation深度网络通用的改进"></a> 5. Depthwise Cross Correlation（深度网络通用的改进）</h1><p><img src="/2020/07/05/siamrpn/image-20200702163749662.png" alt="image-20200702163749662"></p><p><img src="/2020/07/05/siamrpn/image-20200702163802742.png" alt="image-20200702163802742"></p><ul><li><p><strong>Cross Correlation：</strong><br>如上图(a)所示，用于SiamFC中，模版特征在搜索区域上按照滑窗的方式获取不同位置的响应值，最终获得一个一维的响应映射图。</p></li><li><p><strong>Up-Channel Cross Correlation：</strong></p><p>​如上图(b)所示，用于SiamRPN中，和Cross Correlation操作不同的是在做correlation操作之前多了两个卷积层，通道个数分别为256和256x2k，其中k表示每一个锚点上面的anchor个数。其中一个用来提升通道数，而另一个则保持不变。之后通过卷积的方式，得到最终的输出。通过控制升维的卷积来实现最终输出特征图的通道数。</p></li><li><p><strong>Depthwise Cross Correlation：</strong></p><p>​如上图©所示，和UpChannel一样，在做correlation操作以前，模版和搜索分支会分别通过一个卷积层，但并不需要进行维度提升，这里只是为了提供一个非Siamese的特征（SiamRPN中与SiamFC不同，比如回归分支，是非对称的，因为输出不是一个响应值；需要模版分支和搜索分支关注不同的内容）。<br>​在这之后，通过类似depthwise卷积的方法，逐通道计算correlation结果，这样的好处是可以得到一个通道数非1的输出，可以在后面添加一个普通的 1x1卷积就可以得到分类和回归的结果。整个过程类似于构造检测网络的头网络。<br>​这里的改进主要源自于upchannel的方法中，升维卷积参数量极大， 256x(256*2k)x3x3， 光分类分支就有接近6M的参数，回归分支12M。其次升维操作造成了两支参数量的极度不平衡，模版分支是搜索支参数量的 2k/4k 倍，造成了整个网络训练困难的问题。而改为Depthwise版本以后，参数量能够急剧下降；同时整体训练也更为稳定，整体性能也得到了加强。</p></li></ul><p><strong>相同类的目标在相同的通道上有比较高的响应值：</strong></p><p>（前两列person，中间两列car，后两列face）</p><p>​这也是能使用depthwise corr的因素之一，单个通道的特征已经足够明显。</p><p><img src="/2020/07/05/siamrpn/image-20200702163829209.png" alt="image-20200702163829209"></p><h1 id="6-多层rpn"><a class="markdownIt-Anchor" href="#6-多层rpn"></a> 6. 多层RPN</h1><p><img src="/2020/07/05/siamrpn/image-20200702163155149.png" alt="image-20200702163155149"></p><p>​论文分别在conv3_3、conv4_6和conv5_3的分支上使用siamrpn网络，然后把结果整合进行加权输出，该思路类似于CVPR2019的C-RPN算法，通过多级联合具有两个优点：</p><ul><li>可以通过多个siamrpn来选择出多样化的样本或者具有判别性的样本块，第一个siamrpn可以去除掉一些特别简单的样本块，而后面的网络进一步进行滤除，最终剩余一些hard negative sample，这样其实有利于提升网络的判别能力。</li><li>使用多级回归操作，可以获得一个更加准确的bbox。</li></ul><h1 id="7-实验结果"><a class="markdownIt-Anchor" href="#7-实验结果"></a> 7. 实验结果</h1><p><img src="/2020/07/05/siamrpn/image-20200704092513986.png" alt="image-20200704092513986"></p><p><strong>消融实验：</strong></p><p><img src="/2020/07/05/siamrpn/image-20200704092530414.png" alt="image-20200704092530414"></p><p>​主要目的是为了验证本文提出的每一个改进方案的有效性，具体包括使用不同的BackBone网络、是否使用网络层融合、是否进行网络微调操作、是否使用DW卷积等。</p><ul><li><strong>网络方面</strong>，从AlexNet换成了ResNet50以后，我们发现只有conv4的时候就取得了非常好的效果。虽然conv3和conv5效果没有那么好，但由于鲁棒性的提升，使得后续的提升变得有可能。同时对BackBone进行finetune也能带来接近两个点的提升。</li><li><strong>多层特征融合</strong>，从图中看出，同时使用三支的效果明显比单支的要高，VOT上比最好的conv4还要高4个多点。</li><li><strong>使用DW卷积</strong>，从表中也可以看出，无论是AlexNet还是ResNet，装备了新的correlation方式以后，都有接近两个点提升。</li></ul><p><img src="/2020/07/05/siamrpn/image-20200704092649376.png" alt="image-20200704092649376"></p><p><img src="/2020/07/05/siamrpn/image-20200704092707405.png" alt="image-20200704092707405"></p><p><img src="/2020/07/05/siamrpn/image-20200704092726498.png" alt="image-20200704092726498"></p><p><img src="/2020/07/05/siamrpn/image-20200704092746470.png" alt="image-20200704092746470"></p><p><img src="/2020/07/05/siamrpn/image-20200704092806065.png" alt="image-20200704092806065"></p><p><img src="/2020/07/05/siamrpn/image-20200704092838115.png" alt="image-20200704092838115"></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>【精】SiamRPN++算法详解 <a href="https://blog.csdn.net/WZZ18191171661/article/details/88579348">https://blog.csdn.net/WZZ18191171661/article/details/88579348</a></li><li>如何理解 SiamRPN++? <a href="https://www.cnblogs.com/IaCorse/p/12520770.html">https://www.cnblogs.com/IaCorse/p/12520770.html</a></li><li>视觉目标跟踪之SiamRPN++ <a href="https://zhuanlan.zhihu.com/p/56254712">https://zhuanlan.zhihu.com/p/56254712</a></li><li>分组卷积（Group Convolution）与深度可分离卷积（Depthwise Separable Convolution） <a href="https://blog.csdn.net/breeze_blows/article/details/98068025">https://blog.csdn.net/breeze_blows/article/details/98068025</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> RPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> RPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SiamAttn</title>
      <link href="/2020/06/08/siamattn/"/>
      <url>/2020/06/08/siamattn/</url>
      
        <content type="html"><![CDATA[<h1 id="deformable-siamese-attention-networks-for-visual-object-trackingsiamattn"><a class="markdownIt-Anchor" href="#deformable-siamese-attention-networks-for-visual-object-trackingsiamattn"></a> Deformable Siamese Attention Networks for Visual Object Tracking【SiamAttn】</h1><blockquote><p><img src="/2020/06/08/siamattn/image-20200606150148134.png" alt="image-20200606150148134"></p><p>📄 paper: <a href="https://arxiv.org/pdf/2004.06711v1.pdf">https://arxiv.org/pdf/2004.06711v1.pdf</a></p><p>🏙码隆科技: <a href="https://www.malong.com/cn/research.html">https://www.malong.com/cn/research.html</a></p><p>CVPR 2020</p></blockquote><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p><strong>Siamese系列问题：</strong></p><ul><li><p>没有在线更新；</p></li><li><p>模板分支和搜索分支完全独立，一些<strong>背景信息</strong>无法得到有效利用。</p></li></ul><p><strong>注意力机制的应用：</strong></p><ol><li><p><strong>RASNet：</strong></p><p><img src="/2020/06/08/siamattn/image-20200608093015025.png" alt="image-20200608093015025"></p><p>三种注意力：</p><ul><li>残差注意力块、通道注意力块和通用注意力块</li></ul><p><img src="/2020/06/08/siamattn/image-20200608091816705.png" alt="image-20200608091816705"></p><p>创新：</p><ul><li>多个注意力机制使得网络不需要进行在线更新操作，其实是将更新操作换做注意力机制来做；</li><li>通过残差注意力机制和通道注意力机制在缓解网络过拟合的同时提升网络的判别能力；</li><li>考虑到视频中的时空信息，并通道注意力机制来获得</li></ul></li><li><p><strong>FlowTrack</strong></p><p><a href="https://blog.csdn.net/qinhuai1994/article/details/80461271">https://blog.csdn.net/qinhuai1994/article/details/80461271</a></p><p><img src="/2020/06/08/siamattn/image-20200608095719104.png" alt="image-20200608095719104"></p><p>网络架构：</p><p><img src="/2020/06/08/siamattn/image-20200608093821599.png" alt="image-20200608093821599"></p><p>创新：</p><ul><li><p>历史帧：光流+CNN特征，用来补全当前帧的特征，增强鲁棒性；</p></li><li><p>空间注意力 Spatial attention</p><p><img src="/2020/06/08/siamattn/image-20200608095046008.png" alt="image-20200608095046008"></p></li><li><p>时序注意力 Temporal attention (channel attention)</p><p><img src="/2020/06/08/siamattn/image-20200608094712370.png" alt="image-20200608094712370"></p></li></ul></li></ol><p>上述两种方法应用注意力机制的缺点：</p><ul><li>模板分支和搜索分支独立计算注意力</li></ul><h1 id="2-细节"><a class="markdownIt-Anchor" href="#2-细节"></a> 2. 细节</h1><p>从Dual attention network for scene segmentation受启发：</p><p><img src="/2020/06/08/siamattn/image-20200608124833163.png" alt="image-20200608124833163"></p><p>三种Attention机制：</p><ul><li>Self-Attention</li><li>Cross-Attention</li><li>Deformable Attention</li></ul><p>网络架构：</p><p><img src="/2020/06/08/siamattn/image-20200608104249744.png" alt="image-20200608104249744"></p><p><img src="/2020/06/08/siamattn/image-20200608104315288.png" alt="image-20200608104315288"></p>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> Attention </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SiamBAN</title>
      <link href="/2020/06/03/siamban/"/>
      <url>/2020/06/03/siamban/</url>
      
        <content type="html"><![CDATA[<h1 id="siamese-box-adaptive-network-for-visual-trackingsiamban"><a class="markdownIt-Anchor" href="#siamese-box-adaptive-network-for-visual-trackingsiamban"></a> Siamese Box Adaptive Network for Visual Tracking【SiamBAN】</h1><blockquote><p><img src="/2020/06/03/siamban/image-20200525183543042.png" alt="image-20200525183543042"></p><p>📄 paper: <a href="https://arxiv.org/pdf/2003.06761.pdf">https://arxiv.org/pdf/2003.06761.pdf</a></p><p>💻code: <a href="https://github.com/hqucv/siamban">https://github.com/hqucv/siamban</a></p><p>CVPR 2020</p></blockquote><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>缺陷：</p><ul><li>CF类ECO/UPDT：依赖于分类分支，只靠多尺度搜索来估算目标的尺度。</li><li>Siamese系列SiamRPN/DaSiamRPN/SiamRPN++：需要设计anchor box超参数，计算复杂。</li></ul><p>动机：</p><p>​来自神经科学的研究，生物的视觉不需要依靠候选框，主视觉皮层就能快速有效地提取目标的轮廓和边界。所以我们是否可以设计一种不依赖候选框的鲁棒的视觉追踪框架？受到目标检测中Anchor-free检测器的启发。</p><h1 id="2-细节"><a class="markdownIt-Anchor" href="#2-细节"></a> 2. 细节</h1><p><img src="/2020/06/03/siamban/image-20200601143104215.png" alt="image-20200601143104215"></p><p>​采用ResNet-50作为Siamese网络的backbone，box adaptive head包括一个分类模块和一个回归模块。</p><ul><li>为了解决ResNet50降低了特征分辨率的问题，作者移除了最后两个卷积block的下采样操作；</li><li>为了增大感受野（receptive field），采用了空洞卷积（atrous convolution），【文中说在SiamRPN/SiamMask中证明了有效？】；</li><li>采用了不同的膨胀率（atrous rate），在conv4和conv5 block中设置stride都为1，atrous rate中conv4为2，conv5为4。</li><li>Multi-level  Prediction：类似于SiamRPN++，作者对conv3-5的特征图进行depth-wise cross-correlation，后再对三个层做自适应加权融合<br><img src="/2020/06/03/siamban/20200323152713812.png" alt="img" style="zoom:200%;"></li><li></li></ul><blockquote><p>问题：如何避免不同层次的重复检测？</p></blockquote><blockquote><p>从classification/regression map变换回和search patch等大小的方法：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo stretchy="false">⌊</mo><mfrac><msub><mi>w</mi><mrow><mi>i</mi><mi>m</mi></mrow></msub><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mo stretchy="false">⌊</mo><mfrac><mi>w</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>×</mo><mi>s</mi><mo separator="true">,</mo><mo stretchy="false">⌊</mo><mfrac><msub><mi>h</mi><mrow><mi>i</mi><mi>m</mi></mrow></msub><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mo stretchy="false">(</mo><mi>j</mi><mo>−</mo><mo stretchy="false">⌊</mo><mfrac><mi>h</mi><mn>2</mn></mfrac><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>×</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\lfloor \frac{w_{im}}{2} \rfloor + (i-\lfloor \frac{w}{2} \rfloor)\times s, \lfloor \frac{h_{im}}{2} \rfloor + (j-\lfloor \frac{h}{2} \rfloor)\times s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7935599999999998em;vertical-align:-0.686em;"></span><span class="mopen">[</span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1075599999999999em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mclose">]</span></span></span></span></span></p><p><img src="/2020/06/03/siamban/image-20200602120406328.png" alt="image-20200602120406328"></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># resized = cv2.resize(img, (342, 342))</span></span><br><span class="line"><span class="comment"># cv2.imwrite('resized_img.jpg', resized)</span></span><br><span class="line">img = cv2.imread(<span class="string">'resized_img.jpg'</span>)</span><br><span class="line"><span class="comment"># img.shape (342, 342, 3)</span></span><br><span class="line">x = np.zeros((<span class="number">684</span>, <span class="number">684</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># x.shape (684, 684, 3)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">342</span>):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">342</span>):</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">x[<span class="number">342</span>+(i<span class="number">-171</span>)*<span class="number">2</span>,<span class="number">342</span>+(j<span class="number">-171</span>)*<span class="number">2</span>,k] = img[i,j,k]</span><br><span class="line">cv2.imwrite(<span class="string">'x.jpg'</span>, x)</span><br></pre></td></tr></table></figure><p><img src="/2020/06/03/siamban/image-20200602122959610.png" alt="image-20200602122959610"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> Attention </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Attention </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LTMU笔记</title>
      <link href="/2020/05/26/ltmu-bi-ji/"/>
      <url>/2020/05/26/ltmu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="high-performance-long-term-tracking-with-meta-updaterltmu"><a class="markdownIt-Anchor" href="#high-performance-long-term-tracking-with-meta-updaterltmu"></a> High-Performance Long-Term Tracking with Meta-Updater【LTMU】</h1><blockquote>  <img src="/2020/05/26/ltmu-bi-ji/image-20200516203018522.png"><p>📄 paper: <a href="https://arxiv.org/pdf/2004.00305.pdf">https://arxiv.org/pdf/2004.00305.pdf</a></p><p>💻 code: <a href="https://github.com/Daikenan/LTMU">https://github.com/Daikenan/LTMU</a></p><p>🌟【CVPR2020 Oral】</p></blockquote><a id="more"></a><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1><ol><li><p>提出了一种新颖的离线训练元更新器，有效地指导了在线跟踪器的更新。</p></li><li><p>在线本地(局部)跟踪器的基础上，引入了长期跟踪框架。提出的长期跟踪框架在低风险的情况下可受益于在线更新的短期跟踪器的优势。</p><p>Meta-Updater的提出是为了解决一个重要但悬而未决的问题：什么时刻应该更新当前帧？（Is the tracker ready for updating in the current frame?）该元更新器可以按顺序方式有效地整合几何、判别和外观线索，然后使用级联LSTM模块挖掘序列信息。该元更新器学习二进制输出以指导跟踪器的更新，并且可以轻松地嵌入到不同的跟踪器中。</p></li></ol><p>**核心：**长期跟踪+元更新器（Meta-Updater）</p><p>[ ▶ tracking speed  13 FPS]</p><p>Intel-i9 CPU（64G RAM）+NVIDIA GTX2080Ti GPU（11G memory）</p><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><ol><li><p><strong>几何信息（Geometric Cue）</strong>：目标的bounding box信息，就是每帧目标的位置和尺度信息</p></li><li><p><strong>判别信息（Discriminative Cue）</strong>：这里其实就是在线的tracker输出信息（tracker scores， response map），这个信息是非常关键的，很多tracker都是利用这个信息来控制更新的，比如MDNet类，通过看最大的5个分类score的平均值是否大于零来判断是否用这个样本来更新，ATOM通过response map的最大值和形状来判断是否更新。</p></li><li><p><strong>外观信息（Appearance Cue）</strong>：tracker每帧跟踪结果的图片信息和第一帧真值的图片信息。</p></li><li><p><strong>时序信息（Sequential Information）</strong>：对上面信息引入时序，比如几何信息，单独的几何信息信息量很有限，但是引入时序后就可以包含很多信息了，比如轨迹信息，速度信息，加速度信息，尺度变化信息。</p></li></ol><p><img src="/2020/05/26/ltmu-bi-ji/image-20200516214140332-1592291613452.png" alt="image-20200516214140332"></p><h1 id="2-方法"><a class="markdownIt-Anchor" href="#2-方法"></a> 2. 方法</h1><p><img src="/2020/05/26/ltmu-bi-ji/image-20200526110004333.png" alt="image-20200526110004333"></p><p><img src="/2020/05/26/ltmu-bi-ji/image-20200522103348181.png" alt="image-20200522103348181"></p><p><img src="/2020/05/26/ltmu-bi-ji/image-20200523100900734.png" alt="image-20200523100900734"></p><p>local tracker： ATOM+SiamMask</p><p>global tracker： SiamRPN</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><p>【精】【作者】CVPR2020 Oral， LTMU，给跟踪器学习一个长时更新控制器 <a href="https://zhuanlan.zhihu.com/p/130322874">https://zhuanlan.zhihu.com/p/130322874</a></p></li><li><p>High-Performance Long-Term Tracking with Meta-Updater CVPR2020 论文笔记 <a href="https://blog.csdn.net/CptOctopus/article/details/105345965">https://blog.csdn.net/CptOctopus/article/details/105345965</a></p></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> LSTM </category>
          
          <category> Meta Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> LSTM </tag>
            
            <tag> Meta-Learning </tag>
            
            <tag> Meta-Updater </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAML笔记</title>
      <link href="/2020/05/23/maml-bi-ji/"/>
      <url>/2020/05/23/maml-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="mamltracking-by-instance-detection-a-meta-learning-approach"><a class="markdownIt-Anchor" href="#mamltracking-by-instance-detection-a-meta-learning-approach"></a> 【MAML】Tracking by Instance Detection: A Meta-Learning Approach</h1><blockquote><p><img src="/2020/05/23/maml-bi-ji/image-20200501141721053.png" alt="image-20200501141721053"></p><p>paper: <a href="https://arxiv.org/abs/2004.00830">https://arxiv.org/abs/2004.00830</a></p></blockquote><p>MAML :  model-agnostic meta-learning</p><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>​跟踪可以看成是一个特殊的检测问题，即instance detection。主要的区别在于目标检测可以定位某些预定义类别的对象，并且其输出不会在intra-class实例之间进行区分；但是目标追踪仅查找特定实例，该实例可能属于初始帧中指定的任何已知或未知的对象类别。</p><p>​因为两者的相似性，很多目标检测的技术可以应用在目标追踪上面，例如，Faster R-CNN中的RPN网络应用在SiamRPN追踪器及其变体；multi-aspect-ratio anchors解决了困扰之前追踪器的box estimation问题；IoU-Net也应用于ATOM和DiMP中。</p><p>​<strong>给定合适的初始化，检测器从单帧中快速学习实例信息从而转变成一个跟踪器</strong>。难点就在于如何给这个初始化使得模型在少量样本的情况下就能学到一个新的instance的信息而不会过拟合，这就是一个domain adaptation的问题，而model-agnostic meta-learning (MAML) 无疑是解决这种问题的一个利器。</p><p>​这样，我们就可以将一个检测器通过domain adaptation转变成适合某个特定domain （或者说是instance）的跟踪器，下图形象地展示了这个过程。</p><p><img src="/2020/05/23/maml-bi-ji/image-20200503174910896.png" alt="image-20200503174910896"></p><p>具体应用MAML的将detector转变为tracker的流程如下：</p><ol><li><p>使用gradient descent训练一般的检测器；</p></li><li><p>使用MAML在大量跟踪序列上离线训练；</p></li><li><p>给定测试序列第一帧信息后，通过几步gradient descent 来 fine-tune模型参数做domain adaptation从而得到一个跟踪器。跟踪过程中，当目标外观发生变化时，可以用更多样本进行fine-tune得到更好的适应能力。</p></li></ol><p>​作者设计了两个instance detector分别为Retina-MAML和 FCOS-MAML代表着anchor-base和anchor-free，分别来源于RetinaNet和FCOS，均取得了不错的结果，并且速度达到实时的40FPS。</p><blockquote><p><strong>RetinaNet(2018):</strong></p><p>paper: <a href="https://arxiv.org/pdf/1708.02002.pdf">https://arxiv.org/pdf/1708.02002.pdf</a></p><p>blog:</p><ul><li><p>目标检测算法 - RetinaNet <a href="https://zhuanlan.zhihu.com/p/67768433">https://zhuanlan.zhihu.com/p/67768433</a></p></li><li><p>RetinaNet: Focal loss在目标检测网络中的应用 <a href="https://www.jianshu.com/p/8e501a159b28">https://www.jianshu.com/p/8e501a159b28</a></p></li><li><p>Review: RetinaNet — Focal Loss (Object Detection) <a href="https://towardsdatascience.com/review-retinanet-focal-loss-object-detection-38fba6afabe4">https://towardsdatascience.com/review-retinanet-focal-loss-object-detection-38fba6afabe4</a></p></li></ul><p><img src="/2020/05/23/maml-bi-ji/5971313-152cb2d4c07fce20.JPG" alt="img"></p><p><strong>FCOS:</strong></p><p>paper: <a href="https://arxiv.org/pdf/1904.01355.pdf">https://arxiv.org/pdf/1904.01355.pdf</a></p><p>blog:</p><ul><li>FCOS:一阶全卷积目标检测 <a href="https://zhuanlan.zhihu.com/p/63868458">https://zhuanlan.zhihu.com/p/63868458</a></li><li>FCOS: 最新的one-stage逐像素目标检测算法 <a href="https://blog.csdn.net/qiu931110/article/details/89073244">https://blog.csdn.net/qiu931110/article/details/89073244</a></li></ul><p><img src="/2020/05/23/maml-bi-ji/image-20200508095947264.png" alt="image-20200508095947264"></p></blockquote><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><h2 id="21-cnn-based-visual-object-tracking"><a class="markdownIt-Anchor" href="#21-cnn-based-visual-object-tracking"></a> 2.1 CNN-based visual object tracking</h2><p>​首先介绍CNN-based trackers的一些工作，这里作者按照是否显式的使用模板将其分成了两类。</p><p>​template-based的方法通常有一个模板分支，将目标外观信息存储在显式模板中，如常见的siamese系列的跟踪器。这种方法优点是快，不需要在线更新。难点也是难以找到一个合适的在线更新方法来更新模板，从而无法适应一些目标的变化。(SiamFC, SiamRPN, SPM-Tracker, ATOM/DiMP)</p><p>​另一方面template-free的方法就是将目标外观信息以微调参数的形式存储在网络中，比如MDNet。但这类算法的难点一个是慢，一个是容易过拟合，无法很好将instance信息融合进网络。</p><p>​本文设计了一个template-free trackers，作者认为这类方法的整体架构可以很好的匹配一个检测框架，不需要额外添加其他分支改变结构。</p><h2 id="22-meta-learning-and-its-application-to-tracking"><a class="markdownIt-Anchor" href="#22-meta-learning-and-its-application-to-tracking"></a> 2.2 Meta learning and its application to tracking</h2><p>​介绍一些meta-learning的相关工作以及在跟踪中的应用，不过目前这种方法在跟踪中的应用还不够成熟，有些精度不够高，有些速度太慢了。</p><p>​Model-agnostic meta-learning (MAML) [10] is an im-<br>portant algorithm for meta learning.  The most striking merit of MAML is that it is compatible with any model trained with gradient descent and applicable to a variety of different learning problems.<br>Because of this, MAML is a perfect candidate to realize our idea, which is to convert any advanced object detectors (trained with gradient descent) into a tracker.</p><p>MAML++</p><p>MetaSGD</p><p>​Meta-Tracker第一次使用MAML作为MDNet的domain adaptation step；MetaRTT进一步应用MAML作为在线更新步骤，以此加速现有tracker的在线训练速度。</p><p>​We argue that, since meta learning provides a mechanism to quickly adapt a deep network to model a particular object and avoid overfitting, why not directly convert a modern object detector into a tracker, instead of making a slow tracker faster?</p><blockquote><p>ICCV 2019 Lianghua Huang, Xin Zhao, and Kaiqi Huang. <strong>Bridging the gap between detection and tracking: A unified approach</strong></p><p>paper: <a href="http://openaccess.thecvf.com/content_ICCV_2019/papers/Huang_Bridging_the_Gap_Between_Detection_and_Tracking_A_Unified_Approach_ICCV_2019_paper.pdf">http://openaccess.thecvf.com/content_ICCV_2019/papers/Huang_Bridging_the_Gap_Between_Detection_and_Tracking_A_Unified_Approach_ICCV_2019_paper.pdf</a></p><p>blog:</p><ul><li>[Note2] 目标检测框架在目标跟踪中的应用 <a href="https://www.bilibili.com/read/cv4707398">https://www.bilibili.com/read/cv4707398</a></li></ul><p><img src="/2020/05/23/maml-bi-ji/image-20200508101652361.png" alt="image-20200508101652361"></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508101910940.png" alt="image-20200508101910940"></p></blockquote><h1 id="3-learning-an-instance-detector-with-maml"><a class="markdownIt-Anchor" href="#3-learning-an-instance-detector-with-maml"></a> 3. Learning an Instance Detector with MAML</h1><p>要解决的问题：如何通过MAML来学习一个instance detector？</p><p>​将一个detector转化为instance detector的关键在于提供一个好的初始化。</p><p><mark>[➡pdf]</mark></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508173805473.png" alt="image-20200508173805473"></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508205138579.png" alt="image-20200508205138579"></p><p><img src="/2020/05/23/maml-bi-ji/image-20200508173826254.png" alt="image-20200508173826254"></p><p>​整体的流程如下图所示，这里训练的时候简化了，仅选择一对图片来构建一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，第一张图通过缩放得到3张图作为support set，第二张图就直接作为target set。</p><p><img src="/2020/05/23/maml-bi-ji/image-20200502092252377.png" alt="image-20200502092252377"></p><p>​为了稳定训练，作者添加了一些meta-learning中用到的操作。</p><p><mark><strong>Multi-step loss optimization</strong></mark></p><p>​参照MAML++，将inner-level optimization中GD的每一个step的参数都用来优化target set中的loss，而不是只用最后一步得到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">θ_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。则公式2可以改写为：</p><p><img src="/2020/05/23/maml-bi-ji/image-20200508173437682.png" alt="image-20200508173437682"></p><p>​值得注意的是初始参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">θ_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>同样被用于计算outer-level loss。</p><p><mark><strong>Kernel-wise learnable learning rate</strong></mark></p><p>​参照MetaSGD，将公式1中inner-level optimization的学习率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>变为可学习的：</p><p><img src="/2020/05/23/maml-bi-ji/image-20200508174139349.png" alt="image-20200508174139349"></p><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\theta_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>有相同的size，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊙</mo></mrow><annotation encoding="application/x-tex">\odot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">⊙</span></span></span></span>表示element-wise product，若为每个参数设置学习率会使模型大小增加一倍，所以作者这里使用了kernel-wise的方法，给每个卷积核定义了学习率。（大概）</p><h1 id="4-retina-maml-and-fcos-maml"><a class="markdownIt-Anchor" href="#4-retina-maml-and-fcos-maml"></a> 4. Retina-MAML and FCOS-MAML</h1><p>​这一节就是具体将如何通过开始提到的3个步骤来构建跟踪器。包括detector choices, offline training details 和 online tracking process。</p><h2 id="41-detectors"><a class="markdownIt-Anchor" href="#41-detectors"></a> 4.1 Detectors</h2><p>Anchor-based vs Anchor-free</p><p><img src="/2020/05/23/maml-bi-ji/image-20200502092323876.png" alt="image-20200502092323876"></p><p>​作者分别选取了anchor-base的RetinaNet和anchor-free的FCOS来作为检测器。由于跟踪通常会根据目标大小选择一个搜索区域然后将其resize到固定大小输入到网络中，<mark>所以目标尺度在跟踪任务中通常分布比较集中，不需要FPN这样的结构</mark>。另外对于FCOS只保留了centerness 来预测分类得分（FCOS用了三个network head：一个common regression head和两个centerness/classification heads）；Retinanet只设计了一个64×64大小的anchor。</p><p>​整体网络结构如下图4，Resnet18作为backbone，前3个block在ImageNet预训练后在离线训练时冻结，block5被丢弃，block4（黄色部分）复制一份分别独立作用在分类和回归上。</p><p><img src="/2020/05/23/maml-bi-ji/image-20200502092349927.png" alt="image-20200502092349927"></p><h2 id="42-offline-maml-training"><a class="markdownIt-Anchor" href="#42-offline-maml-training"></a> 4.2 Offline MAML training</h2><p><strong>Loss definition:</strong></p><ul><li><p>Retina-MAML</p><p>Focal loss (classification) + smooth L1 loss (regression)</p></li><li><p>FCOS-MAML</p><p>L2 loss (centerness scores) + L1 loss (regression)</p></li></ul><p><strong>Training data:</strong></p><p>​MS-COCO, GOT10k,  TrackingNet, LaSOT-train</p><ul><li><p>cropped and resized into <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>263</mn><mo>×</mo><mn>263</mn></mrow><annotation encoding="application/x-tex">263\times263</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord">3</span></span></span></span></p></li><li><p>data augmentation: random scaling, shifting</p></li></ul><p><strong>Optimization:</strong></p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>What is Model-Agnostic Meta-learning (MAML) ?  <a href="https://towardsdatascience.com/model-agnostic-meta-learning-maml-8a245d9bc4ac">https://towardsdatascience.com/model-agnostic-meta-learning-maml-8a245d9bc4ac</a></li><li>【paper】Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks <a href="https://arxiv.org/pdf/1703.03400.pdf">https://arxiv.org/pdf/1703.03400.pdf</a></li><li>【论文翻译】Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks <a href="https://blog.csdn.net/weixin_40523230/article/details/85005378">https://blog.csdn.net/weixin_40523230/article/details/85005378</a></li><li>【video】MAML: Model-Agnostic Meta-Learning <a href="https://youtu.be/IkDw22a8BDE">https://youtu.be/IkDw22a8BDE</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Meta Learning </category>
          
          <category> Object Detection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Meta-Learning </tag>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiMP</title>
      <link href="/2020/05/18/dimp/"/>
      <url>/2020/05/18/dimp/</url>
      
        <content type="html"><![CDATA[<h1 id="learning-discriminative-model-prediction-for-trackingdimp"><a class="markdownIt-Anchor" href="#learning-discriminative-model-prediction-for-trackingdimp"></a> Learning Discriminative Model Prediction for Tracking【DiMP】</h1><blockquote><p><img src="/2020/05/18/dimp/image-20200509205838642.png" alt="image-20200509205838642"></p><p>📄 paper: <a href="https://arxiv.org/pdf/1904.07220.pdf">https://arxiv.org/pdf/1904.07220.pdf</a></p><p>💻 code: <a href="https://github.com/visionml/pytracking">https://github.com/visionml/pytracking</a></p><p>🌟  ICCV 2019 Oral <a href="https://www.bilibili.com/video/BV1zJ411t7Kb">https://www.bilibili.com/video/BV1zJ411t7Kb</a></p></blockquote><a id="more"></a><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1><p>​Our architecture is derived from <strong>a discriminative learning loss</strong> by designing a dedicated optimization process that is capable of predicting a powerful model in only a few iterations. Furthermore, our approach is able to learn key aspects of the discriminative<br>loss itself.</p><p>[ ▶running at over 40 FPS]</p><p>单卡GTX 1080</p><ul><li><p>57FPS ⚡ ResNet-18 as backbone</p></li><li><p>43FPS ⚡ ResNet-50 as backbone</p></li></ul><blockquote><p>什么是discriminative learning？</p><p>可以有效地利用背景信息的方法。</p></blockquote><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>Siamese系列的三大缺点：</p><ol><li>Siamese的网络框架一般都只是把模板割出来，忽略了背景信息的利用，而背景的信息对目标的检测定位也是至关重要的；【判别性学习loss】</li><li>因为跟踪一般都是很多没有见过的类，通过offline学习的相似性度量可能不是很适用；【判别性学习loss+在线更新最速梯度下降法微调】</li><li>Siamese的框架没有一个合适的模型更新方式。【保留50个历史样本帧 + 每20帧使用两步最速下降法迭代微调target model f + 检测到distractor peak（干扰）时一步最速下降迭代】</li></ol><p>​we take inspiration from the discriminative learning procedures that have been successfully applied in recent trackers [26（MDNet）, 7（C-COT）, 4（ATOM）].</p><p>two key design choices:</p><ol><li>we employ a <strong>steepest descent</strong> based methodology that computes an optimal step length in each iteration.</li><li>we integrate a module that effectively initializes the target model.</li></ol><p>benchmark：</p><ul><li>NFS [9], UAV123 [24], OTB100 [37], TrackingNet [25], LaSOT [8], GOT10k [13] and VOT2018 [18]</li></ul><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><p>Siamese系列</p><ul><li><p>SiamFC[1]：全卷积结构</p></li><li><p>RASNet[36]：residual attention mechanism（应用了注意力机制）</p><p>🏷 <a href="https://blog.csdn.net/uhrehjjbk/article/details/84862202">https://blog.csdn.net/uhrehjjbk/article/details/84862202</a></p><p>🏷 ​https://blog.csdn.net/weixin_40610037/article/details/80257287</p><blockquote><p><img src="/2020/05/18/dimp/20181206174550851.png" alt="img"></p><p>三种attention机制</p><p>1、 General Attention：（负责学习所有跟踪目标的共性）【利用先验知识】</p><p>在训练的时候得到的一个包含训练样本通用信息的特征图，得到不同的跟踪目标之间的共同的特征。一幅图的不同位置所表达的重要性不同， 该注意力机制要满足中心位置权重大于周围位置，比如高斯分布，实质是利用了目标在目标图像中心位置的先验知识。通过学习生成一个类似高斯框的结构，表征目标的空间信息（可理解为传统相关滤波中的期望的高斯响应的Map）。</p><p>2、 Residual Attention：（负责学习不同跟踪目标的差异性）【微调】</p><p>通过沙漏网络得到跟踪目标之间的差异的特征图。用于表征目标的语义信息，增加判别能力。</p><p>3、 Channel Attention：（负责是模型适应不同的contexts）【SENet】</p><p>经过卷积神经网络提取的特征通常包含多个通道channel，不同的通道得到的特征图不一样，每一层通道代表某种特定的模式信息。在不同场景下，不同通道可能具有不同的具有相异的显著性，通过通道注意力机制来选取对跟踪效果比较好的通道，剔除噪声通道。</p><p>4、weighted cross correlation</p><p>用加权相关滤波表示跟踪目标的特征，找到一个响应值最大的跟踪框。</p>  <img src="/2020/05/18/dimp/20181213172037983.png" alt="img" style="zoom:200%;"><p>Dual attention是Residual Attention和General Attention相加的结果，Dual Attention与Channel Attention进行加权相乘得到融合结果。</p></blockquote></li><li><p>SiamRPN[21]：RPN网络</p></li></ul><p>​Siamese系列的方法一个关键性的限制就是<strong>无法将背景区域信息或之前预测的帧信息有效地整合到模型预测中</strong>。DSiam[10]（动态孪生网络）学习特征的transformation来处理目标表观的变化和抑制背景。DaSiamRPN[40]在目标跟踪期间通过从目标模板中减去相应的图像特征来处理background distractors。（ ❓存疑，待看原文）</p><p>​另一类方法（MDNet、ECO、ATOM）通过在线学习一个discriminative classifier来从背景中区分目标。该类方法可以有效地应用背景信息，因此结果比较鲁棒。然而，这些方法依赖于更复杂的online learning procedure，<u>不易使用end-to-end学习模型来描述</u>。因此，这些方法经常是局限于从预训练的深度网络中提取特征。</p><p>​CFNet将CF的单样本闭式解整合到了深度网络中，但这个简单的CF模型缺乏判别力，效果比Siamese baseline差。RTINet在BACF Tracker中展开ADMM迭代，以在复杂的多阶段训练中学习特征提取器和一些超参数。但BACF模型仅限于傅里叶域CF公式的单样本变体，这样的公式无法利用多个样本，需要滤波器的特殊线性组合才能进行模型调整。Meta-tracker提出了将元学习运用到初始目标独立模型上，然后使用具有学习步长的梯度下降进行refine。但此策略仅适用于模型的初始适应，在以迭代方式应用时表现没有提高，因为模型不可能学习恒定的步长来达到既能快速的初始适应，又能optimal convergence。</p><blockquote><p>这句话是什么意思？</p></blockquote><p><img src="/2020/05/18/dimp/image-20200509214225790.png" alt="image-20200509214225790"></p><h1 id="3-method"><a class="markdownIt-Anchor" href="#3-method"></a> 3. Method</h1><p>两个理论基础：</p><ul><li>一个判别力强的损失函数可以指导网络学到鲁棒的特征</li><li>一个powerful的优化器可以加快网络收敛</li></ul><p>网络结构：（bbox estimation branch没有画出）</p><p><img src="/2020/05/18/dimp/image-20200509214300357.png" alt="image-20200509214300357"></p><p>​对bbox estimation分支采用ATOM中的overlap maximization based architecture。</p><p><img src="/2020/05/18/dimp/20190731160156261.png" alt="整体架构"></p><h2 id="31-discriminative-learning-loss"><a class="markdownIt-Anchor" href="#31-discriminative-learning-loss"></a> 3.1 Discriminative Learning Loss</h2><p>问题：</p><ol><li>简单地求差使模型过分关注负样本，而不是学习到强的判别能力。</li><li>没有解决目标和背景的不平衡问题。</li></ol><h2 id="32-optimization-based-architecture"><a class="markdownIt-Anchor" href="#32-optimization-based-architecture"></a> 3.2 Optimization-Based Architecture</h2><p><img src="/2020/05/18/dimp/image-20200509214353176.png" alt="image-20200509214353176"></p><p><img src="/2020/05/18/dimp/image-20200509214327720.png" alt="image-20200509214327720"></p><h1 id="4experiments"><a class="markdownIt-Anchor" href="#4experiments"></a> 4.Experiments</h1><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li><p>【精】【DiMP】Learning Discriminative Model Prediction for Tracking论文阅读 <a href="https://blog.csdn.net/sinat_31184961/article/details/89512108">https://blog.csdn.net/sinat_31184961/article/details/89512108</a></p></li><li><p>【精】DiMP:Learning Discriminative Model Prediction for Tracking <a href="https://blog.csdn.net/xwmwanjy666/article/details/98500578">https://blog.csdn.net/xwmwanjy666/article/details/98500578</a></p></li><li><p>【Oral翻译】<a href="https://www.bilibili.com/read/cv4053561">https://www.bilibili.com/read/cv4053561</a></p></li><li><p>[工程优化]共轭方向法(Conjugate direction method)的共轭梯度法(Conjugate gradient method)实现【附python代码】 <a href="https://blog.csdn.net/Shenpibaipao/article/details/89396983">https://blog.csdn.net/Shenpibaipao/article/details/89396983</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> IoU-Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoU-Net </tag>
            
            <tag> Siamese network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Siam R-CNN</title>
      <link href="/2020/05/01/siam-r-cnn/"/>
      <url>/2020/05/01/siam-r-cnn/</url>
      
        <content type="html"><![CDATA[<h1 id="siam-r-cnn-visual-tracking-by-re-detection"><a class="markdownIt-Anchor" href="#siam-r-cnn-visual-tracking-by-re-detection"></a> Siam R-CNN: Visual Tracking by Re-Detection</h1><blockquote><p><img src="/2020/05/01/siam-r-cnn/image-20200501141641949.png" alt="image-20200501141641949"></p><p>paper: <a href="https://arxiv.org/abs/1911.12836">https://arxiv.org/abs/1911.12836</a></p><p>TF code: <a href="https://github.com/VisualComputingInstitute/SiamR-CNN">https://github.com/VisualComputingInstitute/SiamR-CNN</a></p><p>project: <a href="http://www.vision.rwth-aachen.de/page/siamrcnn">http://www.vision.rwth-aachen.de/page/siamrcnn</a></p></blockquote><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p>​本文基于的范式是利用重检测进行视频目标追踪。前期利用重检测进行视觉目标追踪的方法通常会受到相似干扰物的影响，其解决策略主要是利用先前的预测提供强位置先验信息和模型在线更新，但是这两种方法都避免不了模型的漂移问题。</p><blockquote><p>什么是re-detect？</p></blockquote><p><strong>主要工作：</strong></p><ul><li>提出一种新的Siam R-CNN追踪器，利用孪生结构将Faster R-CNN应用于解决视觉目标追踪问题</li><li>提出一种新的<strong>难例挖掘方法</strong>，能有效缓解干扰物对追踪结果的影响</li><li>提出一种<strong>基于Tracklets的动态规划算法</strong>，能够在遮挡、目标消失等挑战中实现有效追踪</li></ul><p>​Siam R-CNN在六个短期追踪基准和四个长期追踪基准中均优于先前提出的方法。另外，利用现有的box-to-segmentation部件能够利用追踪框实现视频目标分割，在四个常见追踪数据集上比仅使用初始框标注进行分割的其他方法性能都好。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200430211701696.png" alt="image-20200430211701696"></p><h1 id="2-related-work"><a class="markdownIt-Anchor" href="#2-related-work"></a> 2. Related Work</h1><p>​<strong>Visual Object Tracking (VOT)</strong>. VOT是在给定对象第一帧边界框的情况下完成视频目标追踪任务。 VOT通常根据基准进行评估，例如OTB [98，99]，年度VOT挑战[47，45]，以及更多[66，38，117，65，43]。 最近，已经提出了许多长期跟踪基准[62、86、23]，这些基准将VOT扩展到了更加困难和真实的设置，其中必须在许多帧上跟踪对象，并且对象会消失并重新出现。</p><p>​许多经典方法使用在线学习的分类器来重新检测整个图像上的感兴趣对象[1、28、2、76、30、77、42]。 相反，Siam R-CNN通过离线训练来学习预期的外观变化而不是在线学习分类器。</p><p>​像我们的Siam R-CNN一样，许多最新方法都使用Siamese体系结构来实现VOT。 孪生区域提议网络（SiamRPN [49]）使用单阶RPN [74]检测器，该检测器通过将深层模板特征与当前帧的深层特征互相关来重新检测模板目标。 在这里，单阶段意味着直接对锚定框anchor[57]进行分类，这与两阶段体系结构[74]相反，后者首先生成提案proposals，然后对齐其特征并在第二阶段对其进行分类。 最近的跟踪方法对SiamRPN进行了改进，使其能够应对相似物的干扰（DaSiamRPN [118]），或者添加了级联（C-RPN [25]），或者使用更深的网络架构（SiamRPN + [114]和SiamRPN ++ [ 48]），或者维护一组多样化的目标模板（THOR [78]）。 这些（还有更多[7，35，63]）仅在先前预测的小窗口内搜索对象。 DiMP [5]在遵循了这种范例的基础上使用元学习来学习鲁棒的目标和背景外观模型。</p><p>​VOT的其他最新发展包括使用在线学习的特定域层[67]，学习自适应空间滤波器正则化[17]，利用类别特定的语义信息[85]，使用连续[20]或分解[18]卷积以及实现精确的卷积，使用重叠预测网络的边界框预测[19]。Huang等学者 [39]提出了一种将任意一种检测器转换成跟踪器的框架。 像SiamR-CNN一样，它们也应用两阶段体系结构，但是它们的方法依赖于元学习，并且精度要低得多。</p><p>​当检测置信度较低时，主要通过扩大这些孪生跟踪器的搜索窗口来解决长期跟踪问题[118，48]。 相比之下，我们使用两阶孪生检测器来搜索整个图像，从而在许多基准测试中产生比当前方法更好的结果，尤其是对于长期跟踪而言。</p><p>Video Object Segmentation (VOS). VOS是VOT的扩展，其中提供了一组模板分割掩膜，并且需要在每个帧中生成分割掩膜。 许多方法都在模板掩膜的基础上进行微调[8、64、89、52、3、60]，这种方法可以产生非常好的分割结果，但是速度很慢。 最近，有几种方法在没有微调的情况下使用了第一帧掩膜[12、105、13、37、100、101、87、69]，运行速度更快，但通常效果不佳。<br>  有零星的几个的方法[94，108]解决仅在使用给定模板边界框而不使用掩膜的情况下产生掩膜跟踪结果的难题。 我们调整了在此设置中调整Siam R-CNN来解决VOS的任务，通过使用第二个网络为框跟踪结果生成掩膜。</p><h1 id="3-method"><a class="markdownIt-Anchor" href="#3-method"></a> 3. Method</h1><p>​受孪生跟踪器[45，99，47]成功的启发，我们将孪生架构用于重新检测器。 许多最新的跟踪器[118、94、48、49、5]采用单阶检测器架构。 对于单图像物体检测的任务，已显示出诸如Faster R-CNN [74]之类的两阶检测器网络优于单阶检测器。 受此启发，我们将跟踪器设计为孪生两阶检测网络。 第二阶段可以通过串联感兴趣区域（RoI）对齐的特征，直接将提议的感兴趣区域（RoI）与模板区域进行比较。</p><p>​通过将提议区域和参考图像对齐到相同的尺寸，Siam RCNN可以对对象尺寸和纵横比变化保持鲁棒性，而使用流行的互相关操作很难做到这一点[49]。 图2显示了包括Tracklet动态规划算法（TDPA）的Siam R-CNN的概述。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200425132012693.png" alt="image-20200425132012693"></p><h2 id="31-siam-r-cnn"><a class="markdownIt-Anchor" href="#31-siam-r-cnn"></a> 3.1 Siam R-CNN</h2><p>​Siam R-CNN是基于两阶检测架构的孪生重检测器。 具体来说，我们采用了在COCO [56]数据集上经过预训练的用于检测80个对象类别的Faster R-CNN网络。</p><p>​ 该网络由骨干特征提取器和随后的两个检测阶段组成。 首先是与类别无关的RPN，然后是用于特定于类别的检测头。 我们固定骨干网和RPN的权重，并用我们的重检测头替换类别特定的检测头。我们通过执行RoI Align [33]为该建议区域提取深层特征，为RPN建议的每个区域的重检测头创建输入特征。我们还在第一帧中获取了初始化边界框的RoI Aligned深层特征，然后将它们串联在一起，并将合并的特征馈入1×1卷积中，这将特征通道的数量减少了一半。 然后将这些聚合特征送入带两个输出类别的重检测头中：拟议的区域要么是参考目标，要么不是。</p><p>​我们的检测头使用三级级联[9]，没有共享权重。 重新检测头的结构与Faster R-CNN的检测头的结构相同，不同之处在于仅使用两个输出类，并且通过串联创建重检测头的输入特征。 将主干和RPN参数冻结，并且使用视频数据集中的成对帧仅对重检测头（连接后）进行跟踪训练。 在这里，将一帧中的对象用作参考，并训练网络来重新检测另一帧中的同一对象。</p><h2 id="32-video-hard-example-mining"><a class="markdownIt-Anchor" href="#32-video-hard-example-mining"></a> 3.2 Video Hard Example Mining</h2><p>​在常规的Faster R-CNN训练期间，从目标图像中RPN提议的区域中采样第二阶段的负训练样本。 但是，在许多图像中，只有很少的相关负样本。 为了最大程度地提高重检测头的判别能力，我们需要在严格的负样本上进行训练。 在以前的工作中已经探索了进行检测的难例挖掘（例如[26，79]）。 但是，与寻找用于检测的通用难例挖掘方法不同，我们通过从其他视频中检索参考对象来构建困难训练样本。</p><h3 id="1-embedding-network"><a class="markdownIt-Anchor" href="#1-embedding-network"></a> (1) Embedding Network</h3><blockquote><p>这个Embedding Network网络其实就是一个特征提取网络，提取ground truth bbox图像区域的特征，用这个特征代表这块图像对象。因为提取的是代表特征，所以它应该具有同一对象的特征距离会很近，而不同对象的特征之间的距离会很远。</p></blockquote><p>​为当前视频建构难例的一个直观方法是选择相关的视频，这些视频里有和当前目标相同的类别[118]。 但是，对象类别标签并不总是可用，并且同一类的某些对象可能易于区分，而不同类的某些对象也可能是难例。</p><p>​因此，我们建议使用embedding network，它是受<mark>行人重识别</mark>启发的，该网络为该对象外观的每个GT边界框提取一个嵌入向量来代表这个对象。 我们使用来自PReMVOS [60]的网络，该网络使用batch-hard triplet loss[36]，先在COCO的各个类别上进行训练，然后再在YouTube-VOS上进行训练以消除各个对象实例之间的歧义。 例如，在嵌入空间中，两个不同的对象应该相距较远，而不同帧中的同一对象之间距离应相近。</p><blockquote><p>怎么消除歧义？</p></blockquote><blockquote><p><strong>MS COCO</strong> <a href="http://cocodataset.org/#home">http://cocodataset.org/#home</a></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501085453272.png" alt="image-20200501085453272"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501085601130.png" alt="image-20200501085601130"></p><p><strong>YouTube-VOS</strong> <a href="https://youtube-vos.org/">https://youtube-vos.org/</a></p><ul><li>4000+ high-resolution YouTube videos</li><li>90+ semantic categories</li><li>7800+ unique objects</li><li>190k+ high-quality manual annotations</li><li>340+ minutes duration</li></ul><p><img src="/2020/05/01/siam-r-cnn/image-20200501085541966.png" alt="image-20200501085541966"></p></blockquote><h3 id="2-index-structure"><a class="markdownIt-Anchor" href="#2-index-structure"></a> (2) Index Structure</h3><p>​接下来，我们构建了类似最近邻查询结构，创建了有效的索引结构，并使用它在嵌入空间中找到被跟踪对象的最近邻 （可能是被追踪对象的 困难样例） 。 图3示出了所检索的难例负例的例子。 可以看出，大多数负例都是非常相关和很难差别。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501101651228.png" alt="image-20200501101651228"></p><h3 id="3-training-procedure"><a class="markdownIt-Anchor" href="#3-training-procedure"></a> (3) Training Procedure</h3><blockquote><p>Embedding Network 和 Index Structure 都是为了Training Procedure中提供更高效的训练难例提取而设计的。</p><p>大致的思路就是，先提取每个真值追踪框的ROI aligned特征，然后在训练的过程中，由Index Structure生成选取的追踪对象的难例，完成训练。这里的难例与追踪对象是非常相似的，这种训练方法应该是可以提高网络对同类的不同实例的差别能力。</p></blockquote><p>​从其他视频中在线评估主干网络来检索当前视频帧的难例是非常昂贵的。 取而代之的是，我们为训练数据的GT真实框预先计算了与RoI对齐的特征。 对于每个训练步骤，通常会选择一个随机视频和该视频中的对象，然后选择一个随机参考图像和一个随机目标帧。 然后，我们使用索引结构从其他视频中为参考框检索10,000个最近邻的边界框，并从其中采样100个作为难例。 可以在补充材料中找到有关视频难例挖掘的更多详细信息。</p><h2 id="33-tracklet-dynamic-programming-algorithm核心"><a class="markdownIt-Anchor" href="#33-tracklet-dynamic-programming-algorithm核心"></a> 3.3 Tracklet Dynamic Programming Algorithm【核心】</h2><p>​我们的Tracklet动态规划算法（TDPA）隐式跟踪感兴趣的对象和潜在的干扰对象，因此干扰对象可以始终被抑制。 为此，TDPA维护一组tracklets，就是一个短的检测序列（short sequences of detections），几乎可以确定tracklets中的检测序列是属于同一对象的。 然后，它使用基于得分的动态规划算法为第一帧和当前帧中的模板对象选择tracklets中最有可能的序列。</p><blockquote><p>所以，TDPA选择的是tracklets中得分最高的一个检测序列</p></blockquote><p>​每个检测都由边界框、重检测得分及其RoI对齐特征进行定义。 此外，每个检测都是一个tracklets的一部分。 一个tracklet具有开始时间和结束时间，它由一组检测定义，从开始到结束时间的每个时间步都进行一次检测。也就是，一个tracklet中不允许有时间间隔。</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501102156111.png" alt="image-20200501102156111"></p><h3 id="1-tracklet-building"><a class="markdownIt-Anchor" href="#1-tracklet-building"></a> (1) Tracklet Building</h3><p>​我们为第一帧GT边界框提取ROI对齐特征（ff_gt_feat），并初始化仅由该框组成的tracklet。对于每个新帧，我们按以下方式更新tracklet set（参见算法1）：</p><p>​我们提取当前帧的骨干特征，并评估区域提议网络（RPN）以获取感兴趣的区域（RoI，第2–3行）。为了补偿潜在的RPN误报，RoI的集合将由前一帧的边界框输出扩展。【应该是利用前一帧预测的bbox】</p><p>​我们在这些RoI上运行重新检测头（包括边界框回归），以生成一组对第一帧模板的重新检测（第4行）。 之后，我们在当前的检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><msub><mi>s</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">dets_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>上重新运行重检测头的分类部分（第6行），但是这次以来自前一帧的检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><msub><mi>s</mi><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">dets_{t-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 作为参考，而不是第一帧GT真实框， 计算每对检测之间的相似性得分（分数）。</p><p>​为了测量两次检测的空间距离==【两次检测的空间距离，在追踪中的含义就是，前一帧的追踪框bbox和当前帧的追踪框bbox之间的距离）】==，我们用其中心坐标x和y表示其边界框，并用宽度w和高度h表示它们的宽度，其中x和w用图像宽度标准化，而y和h用图像高度标准化，所有值都在0到1之间。然后，通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi mathvariant="normal">∞</mi></msub></mrow><annotation encoding="application/x-tex">L_{\infty}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∞</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数给出两个边界框（x1，y1，w1，h1）和（x2，y2，w2，h2）之间的空间距离，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>x</mi><mn>1</mn><mo>−</mo><mi>x</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mn>1</mn><mo>−</mo><mi>y</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>w</mi><mn>1</mn><mo>−</mo><mi>w</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo separator="true">,</mo><mi mathvariant="normal">∣</mi><mi>h</mi><mn>1</mn><mo>−</mo><mi>h</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\max(|x1-x2|,|y1-y2|,|w1-w2|,| h1-h2|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">2</span><span class="mord">∣</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span><span class="mord mathdefault">h</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord">2</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。为了节省计算量并避免错误匹配，我们仅针对空间距离小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>的检测对计算成对相似度得分，否则将相似度得分设置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>。</p><p>​当与新检测的相似性得分高（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&gt;</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">&gt;\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>）并且没有歧义时，我们通过当前帧检测来扩展前一帧的tracklet（第7-20行）。例如没有其他检测具有与该tracklet相同强度的相似性（小于β），并且没有其他tracklet与该检测具有几乎相同的相似度（小于β）。 只要有任何歧义，我们都会启动一个新的tracklet，它最初包含一个检测。 然后在tracklet评分步骤中消除歧义。</p><blockquote><p>tracklet的扩张和新建的过程大致就是：</p><p>​当当前帧中可以明确检测到追踪目标时，就把这个检测加入到tracklet中，如果当前帧的检测结果有可能不是待追踪目标，那么就新那一个tracklet。就是在启动新tracklet的过程中，会自动隐式地追踪到相似干扰物，但是通过动态规划求解，可以求解出待追踪目标的tracklet序列。</p><p>​a是一个tracklet,tracklet是一个检测序列，A代表一个追踪，也是一个由tracklet组成的序列</p></blockquote><h3 id="2-scoring"><a class="markdownIt-Anchor" href="#2-scoring"></a> (2) Scoring</h3><p>​一个追踪<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(a_1,...,a_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是由N个不重叠的tracklets组成的序列，例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>&lt;</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">end(a_i)&lt;start(a_{i+1}),\forall i\in \{1,...,N-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span> ，其中start和end表示tracklet的开始和结束时间。</p><blockquote><p>​这个式子表明，tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结束时间，肯定在下一个tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的开始时间之前。这也表明tracklet是一组时间上连续的检测。</p><p>​在长期追踪中它可以理解为，在目标的一个存在期间内，每帧检测结果（目标追踪框）的集合。而在长时追踪中，目标可以有多个存在期间，将这多个存在期间的tracklet组合起来，就是在整个视频中对这个目标的追踪A了。</p></blockquote><p>​总得分包含一个度量单独tracklets质量的一元得分和惩罚tracklets之间间空间跳跃的位置得分，例如：</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501123523423.png" alt="image-20200501123523423"></p><p>​其中ff_score代表时间t时的tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i,t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>重检测置信度 <mark>【也就还是检测置信度得分detection score】</mark> ，它来自于使用第一帧真值框作为参考的重检测头。总会有一个tracklet包含第一帧地面真值边界框，我们将其称为第一帧tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>f</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>​一个tracklet中的所有检测detections，都有非常高的机会成为这个tracklet中的初始检测的正确继续 （是初始检测的一个追踪） ，因为有歧义的tracklets会被终止 。因此，对第一帧tracklet的最新检测也是几乎可以肯定是正确对象的最新观察结果。因此，我们还将最近检测到的第一帧tracklet用作重新检测的附加参考信息。这个得分表示为ff_tracklet_score，和ff_score进行线性组合。</p><p>​两个tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之间的位置分数由最后一次检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的边界框<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,w,h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>与第一次检测<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 的边界框之差的负L1范数给出，即：</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501123904078.png" alt="image-20200501123904078"></p><h3 id="3-online-dynamic-programming"><a class="markdownIt-Anchor" href="#3-online-dynamic-programming"></a> (3) Online Dynamic Programming</h3><p>​我们通过维护一个数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>来有效地找到具有最高总得分（等式1）的tracklet序列。数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>中每个tracklet a，存储从第一帧tracklet开始的到以a为结尾的最优tracklet序列的总得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta [a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>。</p><p>​一旦一个tracklet不被扩展了，它将被终止。 因此，对于每个新帧，仅需要重新计算已经扩展或新创建的tracklet的得分。对于一个新的时间步 【一个新的追踪任务？新的视频？】</p><p>​首先，我们将第一帧tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>f</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a_{ff}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>设置为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><msub><mi>a</mi><mrow><mi>f</mi><mi>f</mi></mrow></msub><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\theta[a_{ff}]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。之后，对于每个已经更新或新创建的tracklet a，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>计算方式如下：</p><p><img src="/2020/05/01/siam-r-cnn/image-20200501135000807.png" alt="image-20200501135000807"></p><blockquote><p>​<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo>:</mo><mi mathvariant="normal">end</mi><mo>⁡</mo><mo stretchy="false">(</mo><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo stretchy="false">)</mo><mo>&lt;</mo><mi mathvariant="normal">start</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\tilde{a}:\operatorname{end}(\tilde{a})&lt;\operatorname{start}(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">e</span><span class="mord mathrm">n</span><span class="mord mathrm">d</span></span><span class="mopen">(</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">s</span><span class="mord mathrm">t</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm">t</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span>表示的应该是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span></span></span></span>是一个在a之前的tracklet，这个max求的是在a之前的tracklet中，得分的最大值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[\tilde{a}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mclose">]</span></span></span></span>。</p><p>​整个动态规划方程就是，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>等于tracklet a的重检测质量得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">unary</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\operatorname{unary}(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">u</span><span class="mord mathrm">n</span><span class="mord mathrm">a</span><span class="mord mathrm">r</span><span class="mord mathrm" style="margin-right:0.01389em;">y</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span>加上tracklet a之前的tracklet得分的最大值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">[</mo><mover accent="true"><mi>a</mi><mo>~</mo></mover><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta[\tilde{a}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，再加上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>~</mo></mover></mrow><annotation encoding="application/x-tex">\tilde{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6678599999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6678599999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.35em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">~</span></span></span></span></span></span></span></span></span>和a之间的加权位置得分。</p></blockquote><p>​为了在很长的序列中保持效率，我们允许两个tracklet之间的最大时间间隔为1500帧，这对于大多数应用来说足够长。</p><p>​在当前帧中更新θ之后，我们选择动态规划得分最高的tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>a</mi><mo>^</mo></mover><mi mathvariant="normal">＝</mi><mi>arg</mi><mo>⁡</mo><msub><mo><mi>max</mi><mo>⁡</mo></mo><mi>a</mi></msub><mi>θ</mi><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\hat a ＝ \arg \max _a \theta[a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathdefault">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.25em;">^</span></span></span></span></span></span><span class="mord cjk_fallback">＝</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span>。 如果选定的tracklet $\hat{a} $在当前帧中不包含一个检测，则我们的算法表明该对象不存在 （目标出视野或被完全遮挡） 。 对于需要在每个帧中进行预测的基准，我们使用所选tracklet的最新框，并将其分配为0。</p><h3 id="34-box2seg"><a class="markdownIt-Anchor" href="#34-box2seg"></a> 3.4 Box2Seg</h3><p>​为了为VOS任务生成分割掩膜，我们使用了来自PReMVOS [60]的现成的边界框到分割（Box2Seg）网络。 Box2Seg是具有Xception-65 [16]主干的全卷积DeepLabV3 + [11]网络。 它已经在Mapillary [68]和COCO [56]上受过训练，可以为边界框输出掩膜。 Box2Seg速度很快，在跟踪之后运行它只需每帧每个对象0.025秒。 我们组合重叠的掩膜，以使像素较少的掩膜位于顶部。</p><h1 id="4-experiments"><a class="markdownIt-Anchor" href="#4-experiments"></a> 4. Experiments</h1><p><img src="/2020/05/01/siam-r-cnn/image-20200501140213541.png" alt="image-20200501140213541"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140233721.png" alt="image-20200501140233721"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140259468.png" alt="image-20200501140259468"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140333522.png" alt="image-20200501140333522"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140402743.png" alt="image-20200501140402743"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140430142.png" alt="image-20200501140430142"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140449130.png" alt="image-20200501140449130"></p><p><img src="/2020/05/01/siam-r-cnn/image-20200501140515651.png" alt="image-20200501140515651"></p><p>（1）Box2Seg部件。</p><p>​Box2Seg部件是来自于PReMVOS[60]的现成的边界框到分割掩膜（Box2Seg）网络。Box2Set是以Xception-65为主干的全卷积DeepLabV3+网络。它已经在Maplillary和COCO上进行过训练，转换速度很快，在追踪之后，每个对象只需要增加0.025秒，便可以将边界框输出为分割掩膜。<br>（2）tracklet到底是个什么样的东西？完全没有一个直观的形象。</p><p>​一个追踪<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>a</mi><mi>N</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(a_1,...,a_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是由N个不重叠的tracklets组成的序列，例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>n</mi><mi>d</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>&lt;</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">end(a_i)&lt;start(a_{i+1}),\forall i\in \{1,...,N-1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>，其中start和end表示tracklet的开始和结束时间。 这个式子表明，tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结束时间，肯定在下一个tracklet <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">a_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 的开始时间之前。这也表明tracklet是一组时间上连续的检测。在长期追踪中它可以理解为，在目标的一个存续期间内的每帧检测结果（目标追踪框）的集合。而在长时追踪中，目标可以有多个存续期间，将这多个存续期间的tracklets组合起来，就是在整个视频中对这个目标的追踪A了。</p><blockquote><p>作者在文中说有很好的抗漂移性，可以在消失后轻松地重新检测目标。怎么实现的？</p></blockquote><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>【精】Siam R-CNN: Visual Tracking by Re-Detection 论文学习 <a href="https://blog.csdn.net/PAN_Andy/article/details/104473156">https://blog.csdn.net/PAN_Andy/article/details/104473156</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> Faster RCNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Siamese-Cascaded-RPN</title>
      <link href="/2020/03/16/siamese-cascaded-rpn/"/>
      <url>/2020/03/16/siamese-cascaded-rpn/</url>
      
        <content type="html"><![CDATA[<h1 id="siamese-cascaded-region-proposal-networks-for-real-time-visual-tracking笔记"><a class="markdownIt-Anchor" href="#siamese-cascaded-region-proposal-networks-for-real-time-visual-tracking笔记"></a> Siamese Cascaded Region Proposal Networks for Real-Time Visual Tracking笔记</h1><blockquote><p>MATLAB code： <a href="https://bitbucket.org/hengfan/crpn">https://bitbucket.org/hengfan/crpn</a></p><p>author: Heng Fan, Haibin Ling∗<br><em>Department of Computer and Information Sciences, Temple University, Philadelphia, PA USA</em></p></blockquote><a id="more"></a><h1 id="1-问题和动机"><a class="markdownIt-Anchor" href="#1-问题和动机"></a> 1. 问题和动机</h1><p>Siamese RPN：</p><blockquote><p><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Li_High_Performance_Visual_CVPR_2018_paper.pdf">High Performance Visual Tracking with Siamese Region Proposal Network(CVPR2018)</a></p><h6 id><a class="markdownIt-Anchor" href="#"></a> <img src="/2020/03/16/siamese-cascaded-rpn/1.jpg" alt></h6><p><img src="/2020/03/16/siamese-cascaded-rpn/2.jpg" alt></p></blockquote><p>之前的Siamese RPN存在一些问题：</p><ol><li><p>正负样本的比例不一致，导致Siamese Network 的训练不够有效；大部分的负样本都是简单样本，对最终的结果贡献很小，所以，在出现相似物体的时候，经常会出现跟踪混淆。</p></li><li><p>只有High-Level sematic feature，Low-level spatial features并没有充分的被探索。</p></li><li><p>One-stage Siamese RPN采用单个回归器进行物体的定位，但是实际上并没有很好的处理跟踪中物体的尺寸变换的问题。利用预先定义好的 Coarse anchor Box不能很好的进行精确的定位。</p></li></ol><p>​本文作者引入多级RPN网络（cascading a sequence of RPNs），来解决样本不平衡问题（imbalance problem），同时选择Hard Negative Samples来改善网络鲁棒性，并且还引入多层特征的融合，得到最后更好的特征表达。</p><h1 id="2-网络结构"><a class="markdownIt-Anchor" href="#2-网络结构"></a> 2. 网络结构</h1><h2 id="21-整体结构"><a class="markdownIt-Anchor" href="#21-整体结构"></a> 2.1 整体结构</h2><p><img src="/2020/03/16/siamese-cascaded-rpn/3.jpg" alt="整体结构"></p><p>​Siamese Cascaded RPN由两个部分的网络构成，第一个部分是Siamese Network（中文译为孪生网络），第二个部分是Cascaded Region Proposal Network。</p><h2 id="22-siamese-network"><a class="markdownIt-Anchor" href="#22-siamese-network"></a> 2.2 Siamese Network</h2><p>​作者采用了modified AlexNet来开发该部分网络。网络的两个分支是共享参数的，确保对x和z做相同的变换，这对于后续的similarity metric learning很重要。</p><h2 id="23-cascaded-rpn"><a class="markdownIt-Anchor" href="#23-cascaded-rpn"></a> 2.3 Cascaded RPN</h2><p>​前人的方法大部分都忽略了 class imbalance 的问题，导致在出现相似性物体的时候，效果不佳。此外，他们也仅用 high-level semantic features 来进行跟踪，而很少考虑 multi-level feature。为了解决上述这两个问题，本文提出多阶段的跟踪方法，网络结构细节如下：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/4.jpg" alt="Cascaded RPN"></p><p>​对于每一个阶段的 RPN，其利用 FTB 模块来融合来自第l个 convolutional layer的特征以及high-level feature，融合后的特征可以用下面的公式进行表达：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mi>T</mi><mi>B</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">Φ</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_l(z) = FTB(\Phi_{l-1}(z),\varphi_l(z))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mi>T</mi><mi>B</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">Φ</mi><mrow><mi>l</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_l(x) = FTB(\Phi_{l-1}(x),\varphi_l(x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><h3 id="231-ftb"><a class="markdownIt-Anchor" href="#231-ftb"></a> 2.3.1 FTB</h3><p>再看看整体结构</p><p><img src="/2020/03/16/siamese-cascaded-rpn/3.jpg" alt="整体结构"></p><p>​其中的FTB：feature transfer block结构如下：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/5.jpg" alt="FTB"></p><p>​</p><p>​主要是对较低分辨率的图像利用Deconvlutional layer 进行升分辨率处理，得到特征卷积后，与另外一支进行元素集相加（element-wise summarize）得到最终的结果。</p><p>​对于RPN-1来说，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_1(z)=\varphi_l(z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>φ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_1(x)=\varphi_1(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，文中的multi-stage指的就是存在多个RPN网络。</p><blockquote><p>引用：目标检测中one-stage和two-stage方法的区别就在于有没有RPN。</p></blockquote><p>​对于stage l，计算每一个anchor的分类得分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{c_i^l\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>和regression offsets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{r_i^l\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.107772em;vertical-align:-0.258664em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-2.441336em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>（回归偏移量），计算公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub><mo separator="true">,</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{c_i^l\} = corr([\Phi_l(z)]_{cls},[\Phi_l(x)]_{cls})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1491079999999998em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>r</mi><mi>r</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mo separator="true">,</mo><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{r_i^l\} = corr([\Phi_l(z)]_{reg},[\Phi_l(x)]_{reg})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1491079999999998em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>​where$ [Φ_l (z)]<em>{cls}，[Φ_l(x)]</em>{cls} , [Φ_l (z)]_{reg}$ and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><msub><mo stretchy="false">]</mo><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">[Φ_l (x)]_{reg}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">[</span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> are<br>derived by performing convolutions on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Φ_l (z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>l</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Φ_l (x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>.</p><p>​我们用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">A_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示在阶段<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>的anchor set。根据分类的得分，我们可以过滤掉该集合中negative confidence 大于预先设定的阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>的样本。然后，剩下的样本就构成了新的anchor set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>，并且用于训练<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">RPN_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>。此外，为了提供更好的初始化，我们优化了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">A_{l+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> 中 anchor的center location以及size，所以产生了更加准确的定位。</p><h3 id="232-loss-function"><a class="markdownIt-Anchor" href="#232-loss-function"></a> 2.3.2 Loss Function</h3><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">RPN_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的损失函数为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">ℓ</mi><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mi>l</mi></msub></mrow></msub><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>i</mi></munder><mrow><msub><mi>L</mi><mrow><mi>c</mi><mi>l</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>c</mi><mi>i</mi><mi>l</mi></msubsup><mo separator="true">,</mo><msubsup><mi>c</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup><mo stretchy="false">)</mo><mo>+</mo><mi>λ</mi><munder><mo>∑</mo><mi>i</mi></munder><msubsup><mi>c</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup><msub><mi>L</mi><mrow><mi>l</mi><mi>o</mi><mi>c</mi></mrow></msub><mo stretchy="false">(</mo><msubsup><mi>r</mi><mi>i</mi><mi>l</mi></msubsup><mo separator="true">,</mo><msubsup><mi>r</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\ell_{RPN_l}(\{c_i^l\},\{r_i^l\})=\sum_i {L_{cls}(c_i^{l},c_i^{l^*})+\lambda\sum_i c_i^{l^*} L_{loc}(r_i^l,r_i^{l^*})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1549679999999998em;vertical-align:-0.25586em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.327674em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9473399999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">λ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0500050000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9473399999999998em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9473399999999998em;"><span style="top:-2.4530000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></span></p><p>​其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>r</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup></mrow><annotation encoding="application/x-tex">r_i^{l^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1560039999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8973399999999999em;"><span style="top:-2.441336em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>表示 anchor i 和GT之间的true distance（真实距离？）。服从前人工作，作者也将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>r</mi><mi>i</mi><msup><mi>l</mi><mo>∗</mo></msup></msubsup></mrow><annotation encoding="application/x-tex">r_i^{l^*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1560039999999998em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8973399999999999em;"><span style="top:-2.441336em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7633428571428571em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>设置为 4d 向量，如下所示：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/6.jpg" alt="true distance"></p><p>​其中，x, y, w, h 是 BBox 的中心点及其宽高。与常规的固定anchor不同，C-RPN的anchors可以进行微调：</p><p><img src="/2020/03/16/siamese-cascaded-rpn/7.jpg" alt="anchors"></p><p>​对于第一个阶段的 anchor，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>a</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>y</mi><mi>a</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>w</mi><mi>a</mi><mn>1</mn></msubsup><mo separator="true">,</mo><msubsup><mi>h</mi><mi>a</mi><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">x^1_a,y^1_a,w^1_a,h^1_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>是预先设定的。</p><p>【注】此处关于损失函数讲的不是特别清晰，关于回归损失函数的定义，可以参考</p><ul><li><p><a href="http://papers.nips.cc/paper/5638-faster-r-cnn-towards-real-time-object-detection-with-region-proposal-networks.pdf">Faster RCNN paper</a></p></li><li><p><a href="https://blog.csdn.net/Mr_health/article/details/84970776">【Faster RCNN】损失函数理解</a></p></li></ul><blockquote><p>引用：Faster RCNN损失函数定义</p><p>Faster RCNN的的损失主要分为RPN的损失和Fast RCNN的损失，计算公式如下，</p><p><img src="https://img-blog.csdnimg.cn/20181108105638545.png" alt></p><p>并且两部分损失都包括分类损失（cls loss）和回归损失（bbox regression loss）。</p><ol><li><p>分类损失</p><ul><li><p>RPN分类损失（二分类交叉熵损失）</p><p>RPN网络的产生的anchor只分为前景和背景，前景的标签为1，背景的标签为0。</p></li><li><p>Fast RCNN分类损失（多分类交叉熵损失）</p></li></ul></li><li><p>回归损失</p></li></ol></blockquote><h3 id="233-总结"><a class="markdownIt-Anchor" href="#233-总结"></a> 2.3.3 总结</h3><p>​上述过程构成了所提出的级联RPN（C-RPN）。其最终的损失函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>C</mi><mi>R</mi><mi>P</mi><mi>N</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{CRPN}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就是各个RPN损失函数的和：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">ℓ</mi><mrow><mi>C</mi><mi>R</mi><mi>P</mi><mi>N</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>L</mi></munderover><msub><mi mathvariant="normal">ℓ</mi><mrow><mi>R</mi><mi>P</mi><msub><mi>N</mi><mi>l</mi></msub></mrow></msub></mrow><annotation encoding="application/x-tex">\ell_{CRPN}=\sum_{l=1}^L \ell_{RPN_l}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1304490000000005em;vertical-align:-1.302113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">ℓ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25586em;"><span></span></span></span></span></span></span></span></span></span></span></p><h1 id="3-算法流程"><a class="markdownIt-Anchor" href="#3-算法流程"></a> 3. 算法流程</h1><p><img src="/2020/03/16/siamese-cascaded-rpn/8.jpg" alt="Algorithm"></p><h1 id="4-experiments"><a class="markdownIt-Anchor" href="#4-experiments"></a> 4. Experiments</h1><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221604131.png" alt="image-20200306221604131"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221627393.png" alt="image-20200306221627393"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221642822.png" alt="image-20200306221642822"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221706307.png" alt="image-20200306221706307"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221738139.png" alt="image-20200306221738139"></p><p><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221800658.png" alt="image-20200306221800658"><img src="/2020/03/16/siamese-cascaded-rpn/image-20200306221817134.png" alt="image-20200306221817134"></p>]]></content>
      
      
      <categories>
          
          <category> Siamese network </category>
          
          <category> RPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Siamese network </tag>
            
            <tag> RPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deep Visual Tracking Review</title>
      <link href="/2020/03/15/deep-visual-tracking-review/"/>
      <url>/2020/03/15/deep-visual-tracking-review/</url>
      
        <content type="html"><![CDATA[<h1 id="deep-visual-tracking-review-and-experimental-comparison"><a class="markdownIt-Anchor" href="#deep-visual-tracking-review-and-experimental-comparison"></a> Deep Visual Tracking: Review and Experimental Comparison</h1><blockquote><p>Peixia Li, Dong Wang, Lijun Wang, Huchuan Lu</p><p><em>School of Information and Communication Engineering, Faculty of Electronic Information and Electrical Engineering, Dalian University of Technology, Dalian, China</em></p><p>大连理工大学信息与通信工程学院，电子信息与电气工程学院，大连理工大学，中国大连</p></blockquote><blockquote><p>paper：<a href="https://www.sciencedirect.com/science/article/abs/pii/S0031320317304612">https://www.sciencedirect.com/science/article/abs/pii/S0031320317304612</a></p></blockquote><a id="more"></a><h2 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h2><ol><li>使用CNN可以极大提升tracking性能。</li><li>使用CNN可以从surrounding background中得到更精确的tracked object结果；使用CNN的模板匹配通常也会更快。</li><li>深度特征明显优于手工特征。</li><li>不同层次卷积层得到的特征有不同的特点（低层次空间特征、高层次语义特征），有效地综合会使tracker更鲁棒。</li><li>端到端的网络通常会比特征提取网络效果更好。</li><li>最适合的训练方法是：先在视频信息上预训练，然后再结合subsequent observation（子序列信息）在线fine-tune（VP-OL）。</li></ol><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><p><strong>应用场景：</strong></p><ul><li>navigation</li><li>surveillance（监控）</li><li>robotics</li><li>traffic control</li><li>augmented reality</li><li>…</li></ul><p><strong>存在的挑战：</strong></p><ul><li>viewpoint change</li><li>Illumination Variation(光照变化)<br>Scale Variation(尺度变化)</li><li>Occlusion(遮挡) / partial occlusion</li><li>Deformation(形变)</li><li>Motion Blur(运动模糊)</li><li>Fast Motion(快速移动)</li><li>In-Plane Rotation(平面内旋转)</li><li>Out-of-Plane Rotation(平面外旋转)</li><li>Out-of-View(出视野)</li><li>Background Clutters(背景干扰)</li><li>Low Resolution(低分辨率)</li><li>……</li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/20190724102008589.png" alt="img"></p><p><img src="/2020/03/15/deep-visual-tracking-review/20190724102610412.png" alt="img"></p><p><strong>milestone：</strong></p><ul><li><p>IVT, MIL, TLD, APGL1, SCM, ASLAS, STRUCK, and KCF</p></li><li><p>OTB-100, TC128 and VOT2015 （large-scale benchmark）</p></li></ul><p><strong>提出三个问题：</strong></p><ol><li>在基于深度学习的跟踪算法中，它们有什么联系和区别？</li><li>为什么深度学习适用于visual tracking？</li><li>如何更好融合深度网络以及目标跟踪未来发展的方向？</li></ol><p><strong>论文结构：</strong></p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200228151545430.png" alt="image-20200228151545430"></p><h1 id="2-background-and-related-work"><a class="markdownIt-Anchor" href="#2-background-and-related-work"></a> 2. Background and Related Work</h1><h2 id="21-基本概念"><a class="markdownIt-Anchor" href="#21-基本概念"></a> 2.1 基本概念</h2><p>​目标跟踪是从真实场景中跟踪任何目标。目标跟踪由运动模型和观测模型组成，根据观测模型可以将跟踪算法分为生成式方法和判断式方法。结构如下：</p><p><img src="/2020/03/15/deep-visual-tracking-review/20190724111931763.png" alt></p><p>**运动模型： **</p><p>​基于对当前帧的估计，该模型会产生一些在当前帧可能包含的目标候选区或者anchor boxes。</p><p>​describes the states of an object over time and predicts its likely state (e.g., Kalman filter [32] and particle filter [33,34] ).</p><p><strong>观测模型：</strong></p><p>​对候选区域的的特征进行分析，来确定该区域是否为目标区域。</p><p>​depicts the appearance information of the tracked object and verifies predictions in each frame [35] .</p><ul><li><p><strong>生成式方法：</strong></p><p>​搜索和跟踪目标最相似的区域作为跟踪结果，包括模板匹配法、子空间法、稀疏表示法等。</p><p>​Generative methods focus on searching for the regions that are the most similar to the tracked object, including  template-based [32,38,47] , subspace-based [1] , sparse representation [48,49] , to name a few.</p></li><li><p>**判别式方法： **</p><p>​训练一个分类器去区分目标与背景，选择置信度最高的候选样本作为跟踪结果，包括boosting、SVM、朴素贝叶斯法、随机森林法、多示例学习法、度量学习法、结构化学习法、潜在变量学习法、相关滤波法等。</p><p>​discriminative trackers usually consider tracking as a classification problem that distinguishes the tracked objects from its local surrounding backgrounds.</p></li></ul><h1 id="3-deep-visual-tracking"><a class="markdownIt-Anchor" href="#3-deep-visual-tracking"></a> 3. Deep Visual Tracking</h1><p><img src="/2020/03/15/deep-visual-tracking-review/20190724151130529.png" alt="img"></p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200301092150467.png" alt="image-20200301092150467"></p><blockquote><p>说明：</p><p>FEN表示feature extraction network</p><p>EEN表示end-to-end network</p><p>online表示在线学习，每学习一个样本就更新参数，可以理解为batch_size为1</p><p>not online表示脱机学习，每学习一批样本才更新参数，可以理解为batch_size大于1</p></blockquote><blockquote><p>问题：CNN-M和CNN-C中的matching和classification是指什么？</p><p>classification应该是把visual tracking看做分类问题，类似HOG+SVM，</p><p>matching ?</p></blockquote><h2 id="31-网络结构cnnrnnothers"><a class="markdownIt-Anchor" href="#31-网络结构cnnrnnothers"></a> 3.1 网络结构（CNN/RNN/others）</h2><h3 id="1-cnn-m"><a class="markdownIt-Anchor" href="#1-cnn-m"></a> (1) CNN-M</h3><ul><li><p>[84] J. Fan , W. Xu , Y. Wu , Y. Gong , Human tracking using convolutional neural networks, IEEE Transactions on Neural Networks 21 (10) (2010) 1610–1623 .</p></li><li><p>[89] K. Chen , W. Tao , Once for all: a two-flow convolutional neural network for visual tracking, Clin. Orthopaedics Related Res. (2016) . arXiv abs/1604.07507</p></li><li><p>【SiameFC】[23] L. Bertinetto , J. Valmadre , J.F. Henriques , A. Vedaldi , P.H.S. Torr , Fully-convolutional siamese networks for object tracking, in: Proceedings of the European Conference on Computer Vision Workshops, 2016, pp. 850–865 .</p></li><li><p>[22] R. Tao , E. Gavves , A.W.M. Smeulders , Siamese instance search for tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 1420–1429 .</p></li><li><p>[25] D. Held , S. Thrun , S. Savarese , Learning to track at 100 FPS with deep regression networks, in: Proceedings of the European Conference on Computer Vision, 2016, pp. 749–765 .</p></li><li><p>【CFNet】[88] J. Valmadre , L. Bertinetto , J.F. Henriques , A. Vedaldi , P.H.S. Torr , End-to-end representation learning for correlation filter based tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2017,  pp. 2805–2813 .</p></li><li><p>【DCFNet】[93] Q. Wang , J. Gao , J. Xing , M. Zhang , W. Hu , Dcfnet: discriminant correlation filters network for visual tracking, Clin. Orthopaedics Related Res. (2017) . arXiv abs/1704.04057</p></li><li><p>[79] D. Gordon, A. Farhadi, D. Fox, Re3 : Real-time recurrent regression networks for object tracking, Clinical Orthopaedics and Related Research-arXiv  abs/1705.06368.</p></li><li><p>[94] J. Choi, J. Kwon, K. M. Lee, Visual tracking by reinforced decision making, Clinical Orthopaedics and Related Research-arXiv abs/1702.06291.</p></li><li><p>[100] J. Gao, T. Zhang, X. Yang, C. Xu, Deep relative tracking, IEEE Transactions on Image Processing 26 (4) (2017) 1845–1858.</p></li></ul><h3 id="2-cnn-c"><a class="markdownIt-Anchor" href="#2-cnn-c"></a> (2)  CNN-C</h3><ul><li>[91] H. Li, Y. Li, F. Porikli, Deeptrack: Learning discriminative feature representations by convolutional neural networks for visual tracking, in: Proceedings of the British Machine Vision Conference, 2014, pp. 1–11.</li><li>[96] M. Hahn, S. Chen, A. Dehghan, Deep tracking: Visual tracking using deep convolutional networks, Clinical Orthopaedics and Related Research-arXiv abs/1512.03993.</li><li>[95] S. Hong, T. You, S. Kwak, B. Han, Online tracking by learning discriminative saliency map with convolutional neural network, in: Proceedings of the International Conference on Machine Learning, 2015, pp. 597–606.</li><li>[74] N. Wang, S. Li, A. Gupta, D. Yeung, Transferring rich feature hierarchies for robust visual tracking, Clinical Orthopaedics and Related Research-arXiv abs/1501.04587.</li><li>[29] M. Danelljan, G. Häger, F. S. Khan, M. Felsberg, Learning spatially regularized correlation filters for visual tracking, in: Proceedings of the IEEE International Conference on Computer Vision, 2015, pp. 4310–4318.</li><li>[87] C. Ma, X. Yang, C. Zhang, M. Yang, Learning a temporally invariant representation for visual tracking, in: Proceedings of the IEEE International Conference on Image Processing, 2015, pp. 857–861.</li><li>【HCFT】[30] C. Ma, J. Huang, X. Yang, M. Yang, Hierarchical convolutional features for visual tracking, in: Proceedings of the IEEE International Conference on Computer Vision, 2015, pp. 3074–3082.</li><li>【FCNT】[19] L. Wang, W. Ouyang, X. Wang, H. Lu, Visual tracking with fully convolutional networks, in: Proceedings of the IEEE International Conference on Computer Vision, 2015, pp. 3119–3127.</li><li>【STCT】[21] L. Wang, W. Ouyang, X. Wang, H. Lu, STCT: sequentially training convolutional networks for visual tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 1373–1381.</li><li>[98] Y. Chen, X. Yang, B. Zhong, S. Pan, D. Chen, H. Zhang, Cnntracker: Online discriminative object tracking via deep convolutional neural network, Applied Soft Computing 38 (2016) 1088–1098.</li><li>【HDT】[31] Y. Qi, S. Zhang, L. Qin, H. Yao, Q. Huang, J. Lim, M. Yang, Hedged deep tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 4303–4311.</li><li>【MDNet】[20] H. Nam, B. Han, Learning multi-domain convolutional neural networks for visual tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 4293–4302.</li><li>[92] B.Zhuang, L.Wang, <a href="http://H.Lu">H.Lu</a>, Visual tracking via shallow and deep collaborative model, Neurocomputing 218 (2016) 61–71.</li><li>【TCNN】[26] H. Nam, M. Baek, B. Han, Modeling and propagating cnns in a tree structure for visual tracking, Clinical Orthopaedics and Related Research-arXiv abs/1608.07242.</li><li>[28] H. Fan, H. Ling, Sanet: Structure-aware network for visual tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops, 2017.</li><li>【C-COT】[24] M. Danelljan, A. Robinson, F. S. Khan, M. Felsberg, Beyond correlation filters: Learning continuous convolution operators for visual tracking, in: Proceedings of the European Conference on Computer Vision, 2016, pp. 472–488.</li><li>[75] G. Ning, Z. Zhang, C. Huang, Z. He, X. Ren, H. Wang, Spatially supervised recurrent convolutional neural networks for visual object tracking, Clinical Orthopaedics and Related Research-arXiv abs/1607.05781.</li><li>[76] G. Zhu, F. Porikli, H. Li, Robust visual tracking with deep convolutional neural network based object proposals on pets, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops, 2016, pp. 1265–1272.</li><li>[97] C. Ma, Y. Xu, B. Ni, X. Yang, When correlation filters meet convolutional neural networks for visual tracking, IEEE Signal Processing Letters 23 (10) (2016) 1454–1458.</li><li>【MCPF】[85] T. Zhang, C. Xu, M.-H. Yang, Multi-task correlation particle filter for robust object tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2017, pp. 4335–4343.</li><li>【ECO】[86] M. Danelljan, G. Bhat, F. S. Khan, M. Felsberg, ECO: efficient convolution operators for tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2017, pp. 6638–6646.</li><li>[27] S. Yun, J. Choi, Y. Yoo, K. Yun, J. Y. Choi, Action-decision networks for visual tracking with deep reinforcement learning, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2017, pp. 2711–2720.</li><li>[90] J. Choi, H. J. Chang, S. Yun, T. Fischer, Y. Demiris, J. Y. Choi, Attentional correlation filter network for adaptive visual tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2017, pp. 4807–4816.</li><li>【DNT】[99] Z. Chi, H. Li, H. Lu, M. Yang, Dual deep network for visual tracking, IEEE Transactions on Image Processing 26 (4) (2017) 2005–2015.</li></ul><h3 id="3-rnn"><a class="markdownIt-Anchor" href="#3-rnn"></a> (3) RNN</h3><ul><li>[77] Z. Cui, S. Xiao, J. Feng, S. Yan, Recurrently target-attending tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, 2016, pp. 1449–1458.</li><li>[75] G. Ning, Z. Zhang, C. Huang, Z. He, X. Ren, H. Wang, Spatially supervised recurrent convolutional neural networks for visual object tracking, Clinical Orthopaedics and Related Research-arXiv abs/1607.05781.</li><li>【SANet】[28] H. Fan, H. Ling, Sanet: Structure-aware network for visual tracking, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops, 2017.</li><li>[78] G. Zhu, F. Porikli, H. Li, Robust visual tracking with deep convolutional neural network based object proposals on PETS, in: Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition Workshops, 2016, pp. 1265–1272.</li><li>[79] D. Gordon, A. Farhadi, D. Fox, Re3 : Real-time recurrent regression networks for object tracking, Clinical Orthopaedics and Related Research-arXiv abs/1705.06368.</li></ul><h3 id="4-others"><a class="markdownIt-Anchor" href="#4-others"></a> (4) Others</h3><ul><li><p>【DLT】[80] N. Wang, D. Yeung, Learning a deep compact image representation for visual tracking, in: Proceedings of the Advances in Neural Information Processing Systems, 2013, pp. 809–817.</p></li><li><p>[81] J. Kuen, K. Lim, C. Lee, Self-taught learning of a deep invariant representation for visual tracking via temporal slowness principle, Pattern Recognition 48 (10) (2015) 2964–2982.</p></li><li><p>【CNT】[82] K. Zhang, Q. Liu, Y. Wu, M. Yang, Robust visual tracking via convolutional networks without training, IEEE Transactions on Image Processing 25 (4) (2015) 1779–1792.</p></li><li><p>[83] L. Wang, T. Liu, G. Wang, K. L. Chan, Q. Yang, Video tracking using learned hierarchical features, IEEE Transactions on Image Processing 24 (4) (2015) 1424–1435.</p></li></ul><h2 id="32-网络形式feneen"><a class="markdownIt-Anchor" href="#32-网络形式feneen"></a> 3.2 网络形式（FEN/EEN）</h2><h3 id="1-fen-feature-extraction-network"><a class="markdownIt-Anchor" href="#1-fen-feature-extraction-network"></a> (1) FEN (feature extraction network)</h3><ul><li>FEN-SL：使用单层提取特征</li><li>FEN-ML：使用多个层提取特征</li></ul><h3 id="2-een-end-to-end-network"><a class="markdownIt-Anchor" href="#2-een-end-to-end-network"></a> (2) EEN (end-to-end network)</h3><ul><li>EEN-S：produce probability score</li><li>EEN-M：produce map (confidence map/probability map/response map/heat map)</li><li>EEN-B：produce bounding box</li></ul><h2 id="33-网络训练"><a class="markdownIt-Anchor" href="#33-网络训练"></a> 3.3 网络训练</h2><table><thead><tr><th style="text-align:center">缩写</th><th style="text-align:center">全称</th></tr></thead><tbody><tr><td style="text-align:center">NP</td><td style="text-align:center">No Pre-trained</td></tr><tr><td style="text-align:center">IP</td><td style="text-align:center">Image Pre-trained</td></tr><tr><td style="text-align:center">VP</td><td style="text-align:center">Video Pre-trained</td></tr><tr><td style="text-align:center">OL</td><td style="text-align:center">Online Learning</td></tr><tr><td style="text-align:center">NOL</td><td style="text-align:center">No Online Learning</td></tr></tbody></table><p>五类：</p><ul><li><p>NP-OL（No Pre-trained Online Learning）</p></li><li><p>IP-NOL（Image Pre-trained No Online Learning）</p></li><li><p>IP-OL（Image Pre-trained Online Learning）</p></li><li><p>VP-NOL（Video Pre-trained No Online Learning）</p></li><li><p>VP-OL（Video Pre-trained Online Learning）</p></li></ul><h1 id="4-实验部分"><a class="markdownIt-Anchor" href="#4-实验部分"></a> 4. 实验部分</h1><p>语言：全部用MATLAB重新实现</p><p>配置：3.4GHz CPU and a GTX 1080 GPU with 8G memory</p><h2 id="41-evaluation-benchmark"><a class="markdownIt-Anchor" href="#41-evaluation-benchmark"></a> 4.1 Evaluation Benchmark</h2><h3 id="0-vot标准扩展"><a class="markdownIt-Anchor" href="#0-vot标准扩展"></a> (0) VOT标准【扩展】</h3><p>​VOT最终选取了<strong>精度</strong>和<strong>鲁棒性</strong>两个指标，因为在图像跟踪的若干评价标准中，这二者的相关性最弱。</p><h4 id="1-中心误差center-error"><a class="markdownIt-Anchor" href="#1-中心误差center-error"></a> /1. 中心误差：Center Error</h4><p>​中心误差标准值考虑目标中心位置的误差，即目标位置（bounding box）的中心点与人工标注（ground-truth）的目标的中心点，这两者的距离（一般为欧拉距离）小于给定阈值（一般阈值设定为20个像素点）的视频帧的百分比。</p><p>​该方法具有明显的缺点，就是无法衡量目标尺度变化的影响。另外，目标中心的意义有时候不是很明确（如下图）。</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot1.jpg" alt="img"></p><h4 id="2-区域重叠region-overlap"><a class="markdownIt-Anchor" href="#2-区域重叠region-overlap"></a> /2. 区域重叠：Region Overlap</h4><p>区域的重叠率是使用重叠面积的比例进行衡量的。</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot2.jpg" alt="img"></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>=</mo><mfrac><mrow><msubsup><mi>R</mi><mi>t</mi><mi>G</mi></msubsup><mo>⋂</mo><msubsup><mi>R</mi><mi>t</mi><mi>T</mi></msubsup></mrow><mrow><msubsup><mi>R</mi><mi>t</mi><mi>G</mi></msubsup><mo>⋃</mo><msubsup><mi>R</mi><mi>t</mi><mi>T</mi></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\phi = \frac{R_t^G \bigcap R_t^T}{R_t^G \bigcup R_t^T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.4814719999999997em;vertical-align:-0.9631409999999998em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5183309999999999em;"><span style="top:-2.2868690000000003em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8231309999999998em;"><span style="top:-2.454244em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24575599999999992em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8231309999999998em;"><span style="top:-2.454244em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span><span style="top:-3.0448em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24575599999999992em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋂</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9631409999999998em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>​在区域重叠指标上，我们一般使用有效帧的重叠率做平均。除此之外，我们还可以使用重叠率阈值以上帧的比例作为标准：</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot3.jpg" alt="img"></p><h4 id="3-跟踪长度tracking-length"><a class="markdownIt-Anchor" href="#3-跟踪长度tracking-length"></a> /3. 跟踪长度：Tracking Length</h4><p><img src="/2020/03/15/deep-visual-tracking-review/vot4.jpg" alt="img"></p><p>​这一指标是基于中心位置误差的，从跟踪开始到中心像素误差下降到阈值以下的（帧数）长度定义为跟踪长度。</p><h4 id="4-失败率failure-rate"><a class="markdownIt-Anchor" href="#4-失败率failure-rate"></a> /4 失败率：Failure Rate</h4><p><img src="/2020/03/15/deep-visual-tracking-review/100043371-70589-3.jpg" alt="img"></p><p>​在视频跟踪处理的一段序列中，当重叠率低于阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span>时，则判定为跟踪失败，并重新初始化目标框，在这段视频中，跟踪失败的次数以及跟踪失败的位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以被记录下来，则失败率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">F</mi><mi>τ</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{F}_{\tau}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>可以被表示为：</p><img src="/2020/03/15/deep-visual-tracking-review/vot13.jpg" alt="img" style="zoom:150%;"><p>​该公式的意义非常明确，每一段的跟踪长度越短，则失败率越大，最后一帧的失败将不会带来影响。</p><h4 id="5-混合测量hybrid-measures"><a class="markdownIt-Anchor" href="#5-混合测量hybrid-measures"></a> /5. 混合测量：Hybrid Measures 【？】</h4><p><img src="/2020/03/15/deep-visual-tracking-review/vot6.jpg" alt></p><p>​定义了几种混合各种参数的指标，Combined Tracking Performance Score (CoTPS)：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>T</mi><mi>P</mi><mi>S</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mover accent="true"><mi>ϕ</mi><mo>^</mo></mover><mo>+</mo><msubsup><mi>λ</mi><mn>0</mn><mn>2</mn></msubsup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CoTPS=(1-\lambda)(1-\hat{\phi}+\lambda_0^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">λ</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1523199999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>​其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi>ϕ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\phi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1523199999999998em;vertical-align:-0.19444em;"></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9578799999999998em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.16666em;">^</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span></span></span>表示跟踪成功帧的平均重叠率，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\lambda_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是失败帧占的比例，这样就将跟踪精度和成功失败率结合起来了，这个分数越高越好。</p><h4 id="6-效果图performance-plot"><a class="markdownIt-Anchor" href="#6-效果图performance-plot"></a> /6. 效果图：Performance Plot</h4><p>​常用的效果图有area-under-the-curve (AUC)曲线，该曲线和ROC曲线表达的含义差不多，也就是OTB中成功率图的表示方法。</p><h4 id="7-评价指标的效果评估"><a class="markdownIt-Anchor" href="#7-评价指标的效果评估"></a> /7. 评价指标的效果评估</h4><p>​这一部分主要是介绍评估哪些标准可以更好的用来评估跟踪算法，我们才会推荐使用这些指标来衡量跟踪算法的性能。下面图中给出了几种指标可视化示意图，其中能反映出许多问题，也就是说标准选取的重要性。</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot7.jpg" alt="img"></p><p>参与评估的标准有：</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot14.jpg" alt="img"></p><p><strong>评价标准的相关性分析</strong></p><p>​使用上述16个标准，对样本集中的所有指标的数值，计算协方差矩阵，协方差矩阵就代表了评价标准的相关性。下图是协方差矩阵的可视化：</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot8.jpg" alt="img"></p><p>1 是三种中心误差评价方法</p><p>2 包含了平均重叠率，正确跟踪帧的百分比等标准</p><p>​根据相关性分析，相关性最小的两个指标是失败率和失败后重新初始化的重叠率。后面将对这一对指标进行分析。</p><h4 id="8-准确率与鲁棒性accuracy-vs-robustness"><a class="markdownIt-Anchor" href="#8-准确率与鲁棒性accuracy-vs-robustness"></a> /8. 准确率与鲁棒性：Accuracy vs. Robustness</h4><p>​这就是VOT中使用的标准了，A_R pair，AR曲线、AR图、AR排序图等等，说的就是这两个指标。</p><ul><li><p>A：重叠率，就是跟踪成功状态下的平均重叠率。</p></li><li><p>R：鲁棒性，按照如下公式计算：</p><p>​鲁棒性数值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>S</mi></msub><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>S</mi><mo separator="true">⋅</mo><mi>M</mi></mrow></msup></mrow><annotation encoding="application/x-tex">R_S=e^{-S· M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mpunct mtight">⋅</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>是平均失败次数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><msub><mi>F</mi><mn>0</mn></msub><mi>N</mi></mfrac></mrow><annotation encoding="application/x-tex">M=\frac{F_0}{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.233431em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>是序列的长度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">F_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是失败总次数。这里参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>是手工选择的参数，意义就是预期可以连续跟踪<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>帧。</p></li></ul><blockquote><p>问题：鲁棒性的计算公式怎么理解？</p></blockquote><p>A-R图结果：A-R plots:</p><p><img src="/2020/03/15/deep-visual-tracking-review/vot11.jpg" alt="img"></p><h4 id="9-vot中使用的评价标准"><a class="markdownIt-Anchor" href="#9-vot中使用的评价标准"></a> /9. VOT中使用的评价标准</h4><p><strong>EAO：</strong></p><p>​Expect Average Overlap Rate，是用来评价性能的。处理使用A-R plot，还有一种是A-R Ranks plot，就是下面右边的那张图。</p><p><img src="/2020/03/15/deep-visual-tracking-review/voteoa.jpg" alt="img"></p><p>​于是这就是我们最终在VOT相关的Paper上看到的图了。</p><p><strong>EFO：</strong></p><p>​Equivalent Filter Operations，EFO是用来评价性能的，因为性能的比较常常因为计算机性能不同而不够直观，EFO评价标准考虑到了这一点，使用600×600的图像，做30*30窗口的滤波，来得到机器的性能。然后使用跟踪算法处理每帧图像的评价时间除以以上滤波操作的时间，得到了一个归一化的性能参数，就是EFO，是VOT14提出的标准，一直沿用到现在。</p><p>EAO与EFO就构成了VOT16的跟踪算法评价标准。</p><h3 id="1-precision-plots-of-ope"><a class="markdownIt-Anchor" href="#1-precision-plots-of-ope"></a> (1) precision plots of OPE</h3><p><strong>作用：</strong></p><p>​一个序列中所有帧的平均中心位置误差被用于慨括跟踪算法对该序列的总体性能。精确度图能够显示出评估的位置在给定的准确值的阈值距离之内的帧数占总帧数的百分比。该评价标准针对一个序列。</p><p><strong>计算：</strong></p><ol><li><p>计算pixel error</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>=</mo><msqrt><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">dis = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.25612499999999994em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.983875em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.9438750000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width="400em" height="1.28em" viewbox="0 0 400000 1296" preserveaspectratio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25612499999999994em;"><span></span></span></span></span></span></span></span></span></span></p><p>dis表示误差，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示anchor box的中心坐标，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>表示ground truth的中心坐标。</p></li><li><p>判断某帧是否被正确预测</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>≤</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mo>&gt;</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">right = \left\{\begin{aligned}1 &amp;&amp;  {dis\leq\theta}\\0 &amp;&amp;  {dis&gt;\theta}\\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>1表示正确预测，0表示错误预测，dis表示第一步计算的结果，即pixel error，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>表示阈值，一般为20。</p></li><li><p>统计该序列中正确预测的帧数n</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><munderover><mo>∑</mo><mn>1</mn><mi>T</mi></munderover><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">n = \sum^T_1 right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span></p><p>T表示该序列的总帧数，right表示该帧是否被正确预测，即第二步中的结果。</p></li><li><p>计算该阈值下的precision</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mi>n</mi><mi>T</mi></mfrac></mrow><annotation encoding="application/x-tex">p = \frac{n}{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>n表示正确预测的总帧数，T表示该序列中总的帧数。</p></li><li><p>绘制Precision plots of OPE</p><p>设置不同的阈值$\theta <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">第</mi><mn>2</mn><mo>−</mo><mn>4</mn><mi mathvariant="normal">步</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">的</mi><mi>p</mi><mi>r</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">坐</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">点</mi></mrow><annotation encoding="application/x-tex">，重复第2-4步计算对应的precision，将它们以坐标点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">第</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mord cjk_fallback">步</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">坐</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">点</span></span></span></span>(\theta_i, p_i)$形式存储下来，然后绘图。下图为样例：</p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229122329696.png" alt="image-20200229122329696"></p></li></ol><h3 id="2-average-precision-scores"><a class="markdownIt-Anchor" href="#2-average-precision-scores"></a> (2) average precision scores</h3><p>​阈值为20时对应的precision。</p><h3 id="3-success-plots-of-ope"><a class="markdownIt-Anchor" href="#3-success-plots-of-ope"></a> (3) success plots of OPE</h3><p><strong>作用：</strong></p><p>​反映算法在一系列帧中的跟踪性能，也叫AUC图。<br><strong>计算：</strong></p><ol><li><p>计算单帧IOU，也叫单帧accuracy</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>O</mi><mi>U</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∣</mi><mi>G</mi><mo>∩</mo><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><mrow><mi mathvariant="normal">∣</mi><mi>G</mi><mo>∪</mo><mi>A</mi><mi mathvariant="normal">∣</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">IOU = \frac{\vert G\cap A \vert}{\vert G \cup A \vert}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∣</span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>G表示ground truth，A表示anchor box，|·|表示该区域内像素点的个数，也可以理解为G和A相交的面积除以G和A相并的面积。</p></li><li><p>判断该帧是否正确预测</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left right" columnspacing="0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>I</mi><mi>O</mi><mi>U</mi><mo>≤</mo><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>I</mi><mi>O</mi><mi>U</mi><mo>&gt;</mo><mi>θ</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">right = \left\{\begin{aligned}1 &amp;&amp;  {IOU\leq\theta}\\0 &amp;&amp;  {IOU&gt;\theta}\\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.00003em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.75em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"><span class="mord"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p></li><li><p>统计所有序列的总帧数T和正确预测的帧数n</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><munderover><mo>∑</mo><mn>1</mn><mi>m</mi></munderover><mi>s</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>f</mi><mi>r</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">T = \sum^{m}_1 sequence\_frames</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9185100000000004em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><munderover><mo>∑</mo><mn>1</mn><mi>T</mi></munderover><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">n = \sum^T_1 right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span></p></li></ol><p>sequence_frames表示该序列的总帧数，m表示待测序列的总数，right是通过第2步计算出来的结果。</p><ol start="4"><li><p>计算该阈值下的success rate</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>r</mi><mo>=</mo><mfrac><mi>n</mi><mi>T</mi></mfrac></mrow><annotation encoding="application/x-tex">sr = \frac{n}{T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>n表示正确预测的总帧数，T表示待测序列的总帧数。</p></li><li><p>绘制Success plots of OPE</p><p>设置不同的阈值$\theta <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">，</mi><mi mathvariant="normal">重</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">第</mi><mn>2</mn><mo>−</mo><mn>4</mn><mi mathvariant="normal">步</mi><mi mathvariant="normal">计</mi><mi mathvariant="normal">算</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">应</mi><mi mathvariant="normal">的</mi><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>r</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">将</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">坐</mi><mi mathvariant="normal">标</mi><mi mathvariant="normal">点</mi></mrow><annotation encoding="application/x-tex">，重复第2-4步计算对应的success rate，将它们以坐标点</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">第</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord cjk_fallback">步</span><span class="mord cjk_fallback">计</span><span class="mord cjk_fallback">算</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">应</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">将</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">坐</span><span class="mord cjk_fallback">标</span><span class="mord cjk_fallback">点</span></span></span></span>(\theta_i, sr_i)$形式存储下来，然后绘图。下图为样例：</p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229155335926.png" alt="image-20200229155335926"></p></li></ol><h3 id="4-average-success-rate-scores"><a class="markdownIt-Anchor" href="#4-average-success-rate-scores"></a> (4) average success rate scores</h3><p>​阈值为0.5时对应的success rate。</p><h3 id="5-accuracy-robust-rankar"><a class="markdownIt-Anchor" href="#5-accuracy-robust-rankar"></a> (5) accuracy-robust rank（AR）</h3><h3 id="6-expected-accuracy-overlap-eao"><a class="markdownIt-Anchor" href="#6-expected-accuracy-overlap-eao"></a> (6) expected accuracy overlap (EAO)</h3><ol><li><p>将所有序列按照长度分类。</p></li><li><p>令待测tracker在长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">N_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的序列上测试，得到每一帧的accuracy <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Φ</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。</p></li><li><p>对该序列所有帧的accuracy进行平均，得到该序列上的accuracy，即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><msub><mi>N</mi><mi>s</mi></msub></msub><mo>=</mo><mfrac><mn>1</mn><msub><mi>N</mi><mi>s</mi></msub></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>N</mi><mi>s</mi></msub></munderover><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\Phi_{N_s}=\frac{1}{N_s}\sum^{N_s}_{i=1} \Phi(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93343em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord">Φ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.1171050000000005em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8394360000000003em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.311105em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Φ</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span></span></p></li><li><p>使用该tracker对所有长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">N_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的序列都跑一遍，求平均。即：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mi mathvariant="normal">Φ</mi><mo stretchy="true">‾</mo></mover><msub><mi>N</mi><mi>s</mi></msub></msub><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mi mathvariant="normal">Φ</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mi>s</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\overline{\Phi}_{N_s}=\frac{1}{m}\sum^m_{i=1} \Phi(N_s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1334300000000002em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Φ</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Φ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mover accent="true"><mi mathvariant="normal">Φ</mi><mo stretchy="true">‾</mo></mover><msub><mi>N</mi><mi>s</mi></msub></msub></mrow><annotation encoding="application/x-tex">\overline{\Phi}_{N_s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1334300000000002em;vertical-align:-0.2501em;"></span><span class="mord"><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8833300000000001em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Φ</span></span></span><span style="top:-3.80333em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.16454285714285719em;"><span style="top:-2.357em;margin-left:-0.10903em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2501em;"><span></span></span></span></span></span></span></span></span></span>即该tracker在长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>N</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">N_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>序列上的EAO值。</p></li></ol><h3 id="7-equivalent-filter-operationsefo"><a class="markdownIt-Anchor" href="#7-equivalent-filter-operationsefo"></a> (7) Equivalent Filter Operations（EFO）</h3><ol><li>测试该机器在600 * 600图像上对每个像素进行30 * 30滤波的时间。</li><li>跟踪算法耗时除以第一步的时间即EFO值。</li></ol><h2 id="42-otb-100dataset"><a class="markdownIt-Anchor" href="#42-otb-100dataset"></a> 4.2 OTB-100【dataset】</h2><blockquote><p><a href="http://cvlab.hanyang.ac.kr/tracker_benchmark/datasets.html">http://cvlab.hanyang.ac.kr/tracker_benchmark/datasets.html</a></p></blockquote><p>​100个标注视频片段，对11个不同的类型（different attributes）进行了标记，分别为：</p><ul><li>Illumination Variation (IV)</li><li>Scale Variation (SV)</li><li>Occlusion (OCC)</li><li>Deformation (DEF)</li><li>Motion Blur (MB)</li><li>Fast Motion (FM)</li><li>In-Plane Rotation (IPR)</li><li>Out-of-Plane Rotation (OPR)</li><li>Out-of-View (OV)</li><li>Background Clutters (BC)</li><li>Low Resolution (LR)</li></ul><p><strong>评价标准：</strong></p><ul><li><p>distance precision (DP)(%) rate at a threshold of 20 pixels.（序列中centre location error小于给定阈值的比例）</p></li><li><p>overlap success (OS)(%) at an overlap threshold 0.5.（系列中tracking bounding box <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">R_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和ground truth <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mi>G</mi></msub></mrow><annotation encoding="application/x-tex">R_G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>o</mi><mi>U</mi><mo>&gt;</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">IoU&gt;0.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span></span></span></span>的比例，即追踪成功的帧的比率）</p></li></ul><p><strong>实验结果：</strong></p><ul><li><strong>precision plots of OPE</strong></li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229120059979.png" alt="image-20200229120059979"></p><ul><li><strong>11 different attributes（11种类型）</strong></li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229140937933.png" alt="image-20200229140937933"></p><h2 id="43-tc-128dataset"><a class="markdownIt-Anchor" href="#43-tc-128dataset"></a> 4.3 TC-128【dataset】</h2><blockquote><p><a href="http://www.dabi.temple.edu/~hbling/data/TColor-128/TColor-128.html">http://www.dabi.temple.edu/~hbling/data/TColor-128/TColor-128.html</a></p></blockquote><p>​128个使用颜色标记真值的视频序列，包含了Illumination Variation (IV), Scale Variation (SV), Occlusion(OCC), Deformation (DEF), Motion Blur (MB), Fast Motion (FM),In-Plane Rotation (IPR), Out-of-Plane Rotation (OPR), Out-of-View(OV), Background Clutters (BC), and Low Resolution (LR)。（和OTB-100的11个类型相同），同时使用和OTB-100相同的评估指标。</p><p><strong>实验结果：</strong></p><ul><li><strong>precision plots of OPE</strong></li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229140118436.png" alt="image-20200229140118436"></p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229140541563.png" alt="image-20200229140541563"></p><ul><li><strong>Speed</strong></li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229140704579.png" alt="image-20200229140704579"></p><h2 id="44-vot2015dataset"><a class="markdownIt-Anchor" href="#44-vot2015dataset"></a> 4.4 VOT2015【dataset】</h2><blockquote><p><a href="http://www.votchallenge.net/challenges.html">http://www.votchallenge.net/challenges.html</a></p></blockquote><p>​60个标记短视频序列，包含6种类型：occlusion(OCC), illumination change(ILL), motion change(MC), size change(SC), camera motion(CM) and unassigned(US/未指定)。</p><blockquote><p>unassigned未指定是指什么类型情况？</p></blockquote><p>​VOT2015与OTB-100主要的不同在于VOT2015提供re-initialization protocol，例如，如果观察到跟踪失败，则在评估过程中将跟踪器重置为真值状态。</p><p><strong>实验结果：</strong></p><p>(不包括MCPF，因为代码已经打包无法改变。 ？)</p><ul><li><strong>accuracy-robust rank (AR)</strong></li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229151210070.png" alt="image-20200229151210070"></p><ul><li><strong>expected accuracy overlap (EAO)</strong></li></ul><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229151611561.png" alt="image-20200229151611561"></p><h2 id="45-trackers"><a class="markdownIt-Anchor" href="#45-trackers"></a> 4.5 trackers</h2><h3 id="1-16-deep-visual-trackers"><a class="markdownIt-Anchor" href="#1-16-deep-visual-trackers"></a> (1) 16 deep visual trackers</h3><p>​These methods include ECO [86] ,CFNet [88] , MCPF [85] , DNT [99] , DCFNet [93] , MDNet [20] , SANet[28] , TCNN [26] , C-COT [24] , STCT [21] , FCNT [19] , HCFT [30] , HDT[31] , SiameFC [23] , CNT [82] and DLT [80] (the detailed information can be found in Table 2 ). <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><p><strong>各tracker详细信息：</strong></p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229162119683.png" alt="image-20200229162119683"></p><h3 id="2-6-baseline-trackers"><a class="markdownIt-Anchor" href="#2-6-baseline-trackers"></a> (2) 6 baseline trackers</h3><p>In addition, we select 6 baseline trackers including MEEM [43] <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> , KCF [44] <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>, TGPR [55] <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>, SCM [5] <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>, ASLA[6] <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>, and SRDCF [101] <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>.</p><h2 id="46-discussions"><a class="markdownIt-Anchor" href="#46-discussions"></a> 4.6 Discussions</h2><h3 id="1-网络结构分析"><a class="markdownIt-Anchor" href="#1-网络结构分析"></a> (1) 网络结构分析</h3><p>​因为区分正负样本比匹配两个feature patches更容易，所以CNN-C trackers比CNN-M更精确。(see Figs. 6 and 9 ).  CNN-M trackers通常更快 (see Fig. 11)，因为大多数trackers都用Siamese network对先验信息建模而不是在线fine-tuning。？</p><p>​CNN-based deep tracker在overall performance ( Figs. 6 and 9 ) 和different challenge ( Tables 3, 4 and 5 )上均优于传统tracker。主要原因是deep feature比手工特征具有更强的representation ability。手工特征可以被视为深度网络中的浅层特征，仅包含了很少的语义信息。</p><p>​CNN不能对序列信息建模。</p><p>​RNN模型可以描述连续帧之间的时间或空间关系，如ROLO和RNNT，但其表现不够好，未来有待进一步研究。</p><h3 id="2-网络应用分析"><a class="markdownIt-Anchor" href="#2-网络应用分析"></a> (2) 网络应用分析</h3><p><strong>FEN</strong></p><p>​根据经验观察得出，使用多层(FEN-ML)提取特征的tracker(e.g., HCFT [30] and HDT [31] )表现优于只使用单层(FEN-SL)的tracker(such as DLT [80] )。</p><p><strong>EEN</strong></p><p>​许多EEN-S tracker (e.g., MDNet [20] , SANet [28] and TCNN [26] )是基于粒子滤波器框架，取得了很好的效果，但时间开销太大。</p><p>EEN tracker通常表现优于FEN tracker。</p><p>​深度特征相比于传统手工特征有着重大的提升。</p><p>​例如 DeepSRDCF vs SRDCF，HCFT vs KCF，如下图：</p><p><img src="/2020/03/15/deep-visual-tracking-review/image-20200229191610219.png" alt="image-20200229191610219"></p><h3 id="3-网络训练分析"><a class="markdownIt-Anchor" href="#3-网络训练分析"></a> (3) 网络训练分析</h3><h3 id="4-追踪速度分析"><a class="markdownIt-Anchor" href="#4-追踪速度分析"></a> (4) 追踪速度分析</h3><h1 id="5-conclusion-and-further-work"><a class="markdownIt-Anchor" href="#5-conclusion-and-further-work"></a> 5. Conclusion and Further Work</h1><p>对于深度学习算法</p><h2 id="51-存在的缺点"><a class="markdownIt-Anchor" href="#51-存在的缺点"></a> 5.1 存在的缺点</h2><ol><li><p>有很多多余的深度特征，限制了速度和准确率。</p></li><li><p>大多数网络使用VGG提取特征。</p></li><li><p>缺失训练样本。</p></li><li><p>模型的迁移能力（transfer ability of model）。</p></li></ol><h2 id="52-未来发展方向"><a class="markdownIt-Anchor" href="#52-未来发展方向"></a> 5.2 未来发展方向</h2><ol><li>减少冗余特征（reduce the redundancy feature）。</li><li>提出更多网络结构。</li><li>对于训练样本缺失，可以花更多精力集中在无监督或弱监督学习。</li><li>利用强化学习或生成对抗网络生成更多样例可以提高性能。</li><li>在跟踪中使用单样本学习（one-shot learning）【？】。</li></ol><h1 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h1><ul><li>论文笔记Deep visual tracking: Review and experimental comparison <a href="https://blog.csdn.net/u011609063/article/details/97106712">https://blog.csdn.net/u011609063/article/details/97106712</a></li><li>目标跟踪VOT2016 BenchMark评价标准介绍 <a href="http://www.p-chao.com/2017-04-05/%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AAvot2016benchmark%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">http://www.p-chao.com/2017-04-05/目标跟踪vot2016benchmark使用教程/</a></li><li>VOT与OTB评价指标 <a href="https://blog.csdn.net/weixin_43246440/article/details/99761160">https://blog.csdn.net/weixin_43246440/article/details/99761160</a></li><li>目标跟踪数据集OTB、VOT下载 <a href="https://blog.csdn.net/jacke121/article/details/82915914">https://blog.csdn.net/jacke121/article/details/82915914</a></li><li>Visual Tracker Benchmark <a href="http://cvlab.hanyang.ac.kr/tracker_benchmark/benchmark.html">http://cvlab.hanyang.ac.kr/tracker_benchmark/benchmark.html</a> 【包含基准trackers】</li><li>目标跟踪方法总结 <a href="https://blog.csdn.net/u013187057/article/details/83866127">https://blog.csdn.net/u013187057/article/details/83866127</a> 【精】</li><li>Visual Tracking Paper List <a href="https://github.com/foolwood/benchmark_results">https://github.com/foolwood/benchmark_results</a> 【列出了当前的SOTA论文】</li><li>Python re-implementation of some correlation filter based tracker <a href="https://github.com/fengyang95/pyCFTrackers">https://github.com/fengyang95/pyCFTrackers</a></li></ul><h1 id="7-总结"><a class="markdownIt-Anchor" href="#7-总结"></a> 7. 总结</h1><p>列举的论文数量很多</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>We note that both SiameFC [23] , CFNet [88] methods have multiple different implementation versions. Here, SiameFC means SiameFC_3s and CFNet means CFNet_Conv2. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="http://cs-people.bu.edu/jmzhang/MEEM/MEEM.html">http://cs-people.bu.edu/jmzhang/MEEM/MEEM.html</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="http://www.robots.ox.ac.uk/~joao/circulant/index.html">http://www.robots.ox.ac.uk/~joao/circulant/index.html</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="http://www.dabi.temple.edu/~hbling/code/TGPR.htm">http://www.dabi.temple.edu/~hbling/code/TGPR.htm</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="http://ice.dlut.edu.cn/lu/Project/cvpr12_scm/cvpr12_scm.htm">http://ice.dlut.edu.cn/lu/Project/cvpr12_scm/cvpr12_scm.htm</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="http://ice.dlut.edu.cn/lu/Project/cvpr12_jia_project/cvpr12_jia_project.htm">http://ice.dlut.edu.cn/lu/Project/cvpr12_jia_project/cvpr12_jia_project.htm</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p><a href="https://www.cvl.isy.liu.se/research/objrec/visualtracking/regvistrack/">https://www.cvl.isy.liu.se/research/objrec/visualtracking/regvistrack/</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATOM</title>
      <link href="/2020/03/06/atom/"/>
      <url>/2020/03/06/atom/</url>
      
        <content type="html"><![CDATA[<h1 id="atom-accurate-tracking-by-overlap-maximization-笔记"><a class="markdownIt-Anchor" href="#atom-accurate-tracking-by-overlap-maximization-笔记"></a> ATOM : Accurate Tracking by Overlap Maximization 笔记</h1><ul><li>Paper：<a href="https://arxiv.org/pdf/1811.07628">https://arxiv.org/pdf/1811.07628</a></li><li>Code: <a href="https://github.com/visionml/pytracking">https://github.com/visionml/pytracking</a></li></ul><a id="more"></a><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1. 简介</h1><p>tracking problem可以拆分为两个任务：</p><ul><li>classification</li><li>estimation</li></ul><blockquote><p>问题：是否类似于two-stage目标检测，如Faster RCNN?</p></blockquote><h2 id="11-target-estimationofflineiou-predictor"><a class="markdownIt-Anchor" href="#11-target-estimationofflineiou-predictor"></a> 1.1 target estimation（offline，IoU-predictor）</h2><blockquote><p>通过一个bbox来预测目标的状态。?</p></blockquote><p>四个输入：</p><ul><li>当前视频帧的feature</li><li>当前视频帧预测的bounding box</li><li>reference image的feature</li><li>reference image的目标bounding box</li></ul><p>一个输出：</p><ul><li>当前视频帧bbox的IoU预测得分</li></ul><h2 id="12-target-classificationonlineiou-modulation"><a class="markdownIt-Anchor" href="#12-target-classificationonlineiou-modulation"></a> 1.2 target classification（online，IoU-Modulation）</h2><blockquote><p>粗略地将要提取的图像块分为前景和背景，得到一个粗略的目标位置。（）</p></blockquote><p>​用于对提取的proposal进行打分，进行前景和背景的划分。作者采用了基于Conjugate Gradient and  Gauss-Newton的优化策略，替代梯度下降法，可以保证fast online training。</p><h2 id="13-related-work"><a class="markdownIt-Anchor" href="#13-related-work"></a> 1.3  Related Work</h2><p>axis aligned， rotated，</p><p>target classification:</p><ul><li>使用在线训练强分类器来判别，correlatio-based tracker（圆形卷积的对角化变换）</li></ul><p>target estimation:</p><ul><li><p>brute-force multi-scale detection strategy</p></li><li><p>预测bbox是一个complex task，需要目标的high-level a-prior knowledge，近期的方法集中在整合先验知识到离线学习中。</p></li><li><p>SiamRPN，Siamese tracking approaches，缺点是没有在线学习、明确考虑干扰因素，不过也使用了简单的模板更新技术部分解决该问题。</p></li></ul><h1 id="2-网络结构"><a class="markdownIt-Anchor" href="#2-网络结构"></a> 2. 网络结构</h1><h2 id="21-整体架构"><a class="markdownIt-Anchor" href="#21-整体架构"></a> 2.1 整体架构</h2><p><img src="/2020/03/06/atom/20190731160156261.png" alt="整体架构"></p><p>​目标估计和分类任务都使用相同的backbone ResNet-18（pretrained ImageNet，no fine-tuning）</p><blockquote><p>问题：什么是backbone?</p><p>​分类网络中去掉分类器或全连接层的部分，就被成为backbone，即网络的主要结构。</p></blockquote><p>​将当前帧的图片（以及GT）输入到backbone提取特征，得到了Modulation vector，接下来test image也输入到backbone中提取特征，然后将layer 3层的特征经过分类模块（classifier，trained online），预测目标的一个置信度分数（positive coefficients），从而得到一个粗略的BB estimates（位置和宽高）。</p><p>​接着与第一帧得到的Modulation vector进行点乘，根据之前帧得到的粗略的bbox然后随机生成10个bbox，送到目标估计模块（在大量数据上离线训练好的），通过最大化IoU来refine bbox（取iou最高的三个求平均）。</p><blockquote><p>当然在跟踪的时候IoU-Net是不更新的，只更新分类的两层，这部分代码体现在初始化IoU-Net的时候atom.py中的<code>def init_iou_net()</code>方法中的``p.requires_grad=False<code>另外在</code>pytrakcing/utils/loading中net, _ = ltr_loading.load_network(path_full, backbone_pretrained=False)`说明backone不采用预训练模型，而在训练的时候backbone加载的是预训练模型。</p></blockquote><p>​其次，原来的IoU-Net是针对class-special的，而跟踪针对于任意类都可以。所以，利用了第一帧目标的标注信息，获取targe-specific信息，从而得到相应的IoU predictions。因此在跟踪时，给定第一帧的信息很重要，那怎么可以有效利用呢？</p><p>​本文试着和当前帧的特征融合，但是效果很差，最后提出了 modulation-base network架构来预测任意物体的IoU。我觉得这里是作为一个先验条件的，具体的目标估计网络（训练框架）如下：</p><p><img src="/2020/03/06/atom/8.jpg" alt></p><p>​该网络包含两个分支：reference branch和test branch，两个分支都是依赖于ResNet-18 Block 3和ResNet-18 Block 4的feature作为输入。</p><blockquote><p>【补充】</p><p>​追踪针对的目标类别是未知的，而检测问题是依赖于每个类别上的检测。</p><blockquote><p>论文说原有的IoU-Net是class-specific的，原因就在于此。</p></blockquote><p>​但仍需要class-specific IoU predictor来对每一帧进行分析得到high-level nature。因为这个训练过程太费时，故而采用offline training来学习general representation用于IoU predictor。</p></blockquote><h3 id="211-reference-branch"><a class="markdownIt-Anchor" href="#211-reference-branch"></a> 2.1.1 Reference Branch</h3><p>由一个卷积层后接PrPool层和全连接层组成。</p><p><img src="/2020/03/06/atom/9.jpg" alt="Reference Branch"></p><ul><li><p>input</p><p>Feature <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and the target bbox annotation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">B_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> in the reference image.</p></li><li><p>output</p><p>Modulation Vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>B</mi><mn>0</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(x_0,B_0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，size：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><mo>×</mo><msub><mi>D</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">1\times1\times D_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p></li></ul><h3 id="212-test-branch"><a class="markdownIt-Anchor" href="#212-test-branch"></a> 2.1.2 Test Branch</h3><p>​The current image, in which we want to estimate the target bounding box, is processed through the <em>test branch</em>.</p><p>​ It first extracts a  <strong>deep representation</strong> by feeding the backbone features <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> through two convolutional layers followed by a <code>PrPool</code> with the bounding box estimate <em>B</em>.</p><p>​由两个卷积层，后接PrPool组成。</p><p><img src="/2020/03/06/atom/10.jpg" alt="Test Branch"></p><ul><li><p>input</p><p>backbone features <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>  （deep representation）</p></li><li><p>output</p><p>representation <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>z</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">z(x, B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span> ，size​：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>×</mo><mi>K</mi><mo>×</mo><msub><mi>D</mi><mi>z</mi></msub></mrow><annotation encoding="application/x-tex">K\times K\times D_z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>where K is spatial output size of the PrPool layer</p></li></ul><h3 id="213-后续步骤"><a class="markdownIt-Anchor" href="#213-后续步骤"></a> 2.1.3 后续步骤</h3><p>​The computed feature representation of the test image is then <em>modulated</em> by the coefficient vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> via a <strong>channel-wise multiplication</strong>.</p><p>​This creates a target-specific representation for IoU prediction, effectively incorporating the reference appearance information. The modulated representation is finally fed to the IoU predictor module <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>, consisting of three fully connected layers. The predicted IoU of the bounding box <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> is hence given by</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>o</mi><mi>U</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false">(</mo><mi>c</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>z</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IoU(B)=g(c(x_0, B)\cdot z(x,B))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>问题：不知道g是指哪部分？自己理解有无偏差？</p><p>回答：暂时无偏差。</p></blockquote><blockquote><p>问题：这两个branch各自对应了target estimation和target classification中的哪个部分？</p><p>回答：target estimation，负责估计目标的位置。</p></blockquote><h3 id="214-prpool参考"><a class="markdownIt-Anchor" href="#214-prpool参考"></a> 2.1.4 PrPool参考</h3><p>RoI Pooling/ RoI Align /PrRoI Pooling三者的区别：</p><p><img src="/2020/03/06/atom/20190731154944824.png" alt="区别"></p><p>参考文章：</p><ul><li><p><a href="https://everitt257.github.io/blog/2019/02/07/RoI-Explained.html">ROI pooling, align, warping</a></p></li><li><p><a href="https://blog.csdn.net/discoverer100/article/details/90519423">Precise RoI Pooling（PrRoI Pooling）笔记</a></p></li><li><p><a href="https://blog.csdn.net/m_buddy/article/details/85110124">RoI Pooling与RoIWrap Pooling与RoIAlign Pooling与Precise RoI Pooling</a></p></li><li><p><a href="https://blog.csdn.net/u011436429/article/details/80279536">ROI Pooling原理及实现</a></p></li><li><p><a href="https://blog.csdn.net/u011436429/article/details/80277633">Selective Search原理及实现</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/ro0lG3uMUPYNZA9rM3I_YQ">目标检测算法中检测框合并策略技术综述</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/47384261">IoUNet(7)_源码 PrRoIPooling(1)</a></p></li><li><p><a href="https://github.com/vacancy/PreciseRoIPooling">PrePool code implements </a></p></li></ul><h2 id="22-模型训练"><a class="markdownIt-Anchor" href="#22-模型训练"></a> 2.2 模型训练</h2><h3 id="221-off-line-trainingtarget-estimation"><a class="markdownIt-Anchor" href="#221-off-line-trainingtarget-estimation"></a> 2.2.1 off-line training（target estimation？）</h3><p>训练数据集：</p><ul><li>LaSOT dataset（Large-scale Single Object<br>Tracking）</li><li>TrackingNet</li></ul><p>​在最大间隔为50的视频中采样图片对，同时用COCO数据集做数据增强，提取了目标周围的5倍大小的方形区域作为输入</p><blockquote><p>原文中为 From the reference image, we sample a square patch centered at the target, with an area of about <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>5</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">5^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> times the target area.</p></blockquote><p>​同时为了防止以目标为中心过拟合，在test image对position和scale做了抖动（perturbation）。</p><p>​因为没有分类层预测bbox，因此在训练的时候将test image的bbox真值通过增加高斯噪声做了扰动，产生了16 candidate bounding boxe，之后还使用image flipping and color jittering for data augmentation，从而输入到网络作为分类的结果。而test image的真值和扰动后的值做了IoU，从而作为loss进行训练。</p><blockquote><p>另外我们可以从优化器部分看到，训练的时候更新的是哪一块：<code>optimizer=optim.Adam(actor.net.bb_regressor.parameters(),lr=1e-3)</code>，也就是训练iounet那一部分。</p></blockquote><p><strong>训练参数设置：</strong></p><p>​The weights in our head network are initialized using<code>[12]</code>. For the backbone network, we freeze all weights during training. We use the mean-squared error loss function and train for 40 epochs with 64 image pairs per batch. The ADAM <code>[16]</code> optimizer is employed with initial learning rate of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mi mathvariant="normal">−</mi><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{−3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> , and using a factor 0.2 decay every 15 epochs.</p><h3 id="222-online-trackingtarget-classification-by-fast-online-learning"><a class="markdownIt-Anchor" href="#222-online-trackingtarget-classification-by-fast-online-learning"></a> 2.2.2 online tracking（Target Classification by Fast Online Learning）</h3><p>​分类模型由两层全卷积网络组成，如公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">;</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>ϕ</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>ϕ</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo>∗</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x;w)=\phi_2 (w_2 * \phi_1 (w_1 * x))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><ul><li><p>first layer：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">（</mi><mn>1</mn><mo>×</mo><mn>1</mn><mi mathvariant="normal">，</mi><mn>64</mn><mi mathvariant="normal">，</mi><msub><mi>w</mi><mn>1</mn></msub><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">（1\times1，64，w_1）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">（</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord">6</span><span class="mord">4</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span></p></li><li><p>second layer：$（4\times4，1，w_2) $</p></li></ul><p>​x是backbone feature map，由于训练样本上得不到在线跟踪目标的信息，所以分类网络的head是在线训练的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>w</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">w_1,w_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是网络参数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∗</mo></mrow><annotation encoding="application/x-tex">*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span></span></span></span>代表standard multi-channe convolution（多通道卷积）。</p><p><strong>Learning objective based on the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>L</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> classification error：</strong></p><p><img src="/2020/03/06/atom/11.jpg" alt="Learning objective"></p><p>​Each training sample feature map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">x_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> is annotated by the classification confidences <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mrow><mi>W</mi><mo>×</mo><mi>H</mi></mrow></msup></mrow><annotation encoding="application/x-tex">y_j \in \mathbb{R}^{W\times H}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="mbin mtight">×</span><span class="mord mathdefault mtight" style="margin-right:0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span>, set to a sampled Gaussian function centered at the target location. The impact of each training sample is controlled by the weight <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>γ</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">γ_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>, while the amount of regularization on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is set by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>λ</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">λ_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> .</p><p>​通常我们会应用标准的梯度下降或者随机梯度下降法(SGD)法求解，但是这些不适合于在线学习，因为收敛效率太慢。本文作者提出了将共轭梯度下降法与神经网络的反向传播结合起来的新方法。</p><h3 id="223-共轭梯度下降法conjugate-gradient"><a class="markdownIt-Anchor" href="#223-共轭梯度下降法conjugate-gradient"></a> 2.2.3 共轭梯度下降法（Conjugate Gradient）</h3><p>将上式列出的分类损失分为两个部分：</p><p><img src="/2020/03/06/atom/20190731213039188.png" alt></p><p><img src="/2020/03/06/atom/20190731213138893.png" alt></p><p>for j ∈ {1,…,m}, k = 1,2</p><p>所以最后的损失函数</p><p><img src="/2020/03/06/atom/11.jpg" alt="Learning objective"></p><p>​就可以写作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">L(w)=||r(w)||^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mord">∣</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> is the concatenation of all residuals <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_j(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span>.</p><p>利用<code>quadratic Gauss-Newton</code>（近似忽略二阶微分）近似得到:</p><p><img src="/2020/03/06/atom/20190731213639984.png" alt></p><p>进行一阶泰勒展开：</p><p><img src="/2020/03/06/atom/20190731213922510.png" alt></p><p>最终损失函数的公式可以化为：</p><p><img src="/2020/03/06/atom/20190731214021772.png" alt></p><p>​we have defined <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>w</mi></msub><mo>=</mo><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">r_w = r(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mi>w</mi></msub><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>r</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">J_w=\frac{∂r}{∂w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> is the Jacobian of  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span> at <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> （雅可比矩阵）.  The new variable <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∆</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">∆w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∆</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> represents the increment in the parameters <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>.</p><p>​我们需要的变量就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Δw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>用于更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>，可以直接对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">Δw</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>求导，使用Conjugate Gradient(CG)方法来迭代。</p><p><img src="/2020/03/06/atom/12.jpg" alt></p><blockquote><p>问题：为什么论文中最后要求CG转化为了必须要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><msub><mi>J</mi><mi>w</mi></msub><mi>p</mi></mrow><annotation encoding="application/x-tex">J^T_wJ_wp</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.088331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">p</span></span></span></span> 的问题了呢？</p></blockquote><p>因为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi mathvariant="normal">∂</mi><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">(</mo><mi>w</mi><msup><mo stretchy="false">)</mo><mi>T</mi></msup><mi>u</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>r</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>w</mi></mrow></mfrac><mi>T</mi></msup><mi>u</mi><mo>=</mo><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><mi>u</mi></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial w}(r(w)^Tu)=\frac{\partial r}{\partial w}^Tu = J_w^T u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.288671em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.602671em;"><span style="top:-3.8243400000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span></span></span></span></span></p><p>事实上可以整合在backpropagation procedure中。</p><p>其中：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>v</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>s</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>v</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">BackProp(s,v)=\frac{\partial s}{\partial v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.05744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mi>T</mi></msup><mi>u</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mi>J</mi><mi>w</mi><mi>T</mi></msubsup><mi>u</mi></mrow><annotation encoding="application/x-tex">BackProp(r^Tu,w)=J^T_w u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.138331em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault">u</span></span></span></span></span></p><h1 id="3-扩展-iou-net见iou-net"><a class="markdownIt-Anchor" href="#3-扩展-iou-net见iou-net"></a> 3. 扩展： IoU-Net【见<a href="https://soarkey.github.io/2020/03/02/iou-net/">IoU-Net</a>】</h1><blockquote><p>问题：本文中说IoU-Net是class-specific的，为什么？</p><p>对于一般的跟踪为什么不适合？</p><p>回答：原先的IoU-Net主要针对目标检测，物体类别已知，所以是class-specific的，而追踪问题针对的目标很难事先知晓，故而不适合。</p></blockquote><p>当前two-stage的目标检测任务流程：</p><ol><li>RPN找出一系列候选框，区分前景背景。</li><li>类置信度及回归坐标。</li><li>通过NMS，对分类置信度进行排序，过滤掉IoU大与一定阈值的框，得到最终的结果。</li></ol><p>这种方法可能会出现两个问题：</p><ol><li><p>在抑制重复检测时，由于定位置信度的缺失，分类分数通常被用作检测框排名的指标。在下图中，研究者展示了一组案例，其中有更高分类置信度的检测框却与其对应的目标物体有更小的重叠。就像 Gresham 著名的 “劣币驱逐良币”理论一样，分类置信度和定位准确度之间的不匹配可能导致定位更准确的边界框在 NMS 过程中反被更不准确的边界框抑制。</p><p><img src="/2020/03/06/atom/3.jpg" alt></p></li><li><p>缺乏定位置信度使得被广泛使用的边界框回归方法缺少可解释性或可预测性。举个例子，之前的研究报告了迭代式边界框回归的非单调性。也就是说，如果多次应用边界框回归，可能有损输入边界框的定位效果（见下图）。</p><p><img src="/2020/03/06/atom/4.jpg" alt></p></li></ol><h2 id="31-网络架构"><a class="markdownIt-Anchor" href="#31-网络架构"></a> 3.1 网络架构</h2><p><img src="/2020/03/06/atom/5.jpg" alt></p><blockquote><p>RPN (区域候选网络)：基于滑窗的无类别obejct检测器</p><p>详情见Faster RCNN</p><p><img src="/2020/03/06/atom/6.jpg" alt></p><p><img src="/2020/03/06/atom/7.jpg" alt></p></blockquote><h2 id="32-相关"><a class="markdownIt-Anchor" href="#32-相关"></a> 3.2 相关</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/41944858">旷视科技提出IoU-Net，让目标检测用上定位置信度</a></li><li><a href="https://arxiv.org/pdf/1807.11590v1.pdf">IoU-Net paper</a></li><li><a href="https://blog.csdn.net/JNingWei/article/details/78847696">RPN (区域候选网络)</a></li><li><a href="https://blog.csdn.net/ctfabc4425/article/details/81490805">论文笔记：(IOU-Net) Acquisition of Localization Confidence for Accurate Object Detection</a></li></ul><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> 4. 总结</h1><p>​知道了文章的大体思路，用了一些新的数据集来测评，借鉴目标检测的IoU-Net得到一个更精确的bbox，使用高斯牛顿优化方法，（求解非线性最小二乘问题时的一个特例，把黑森矩阵用雅克比矩阵代替，当然这个是有条件的），还是去跑代码吧！这样会有更深的理解。</p><p>​牛顿法在选择方向时，不仅会考虑坡度是否够大，还会考虑你走了一步之后，坡度是否会变得更大。所以，可以说牛顿法比梯度下降法看得更远一点，能更快地走到最底部。（牛顿法目光更加长远，所以少走弯路；相对而言，梯度下降法只考虑了局部的最优，没有全局思想。</p><p>​高斯–牛顿迭代法的基本思想是使用泰勒级数展开式去近似地代替非线性回归模型，然后通过多次迭代，多次修正回归系数，使回归系数不断逼近非线性回归模型的最佳回归系数，最后使原模型的残差平方和达到最小。</p><h1 id="5-experiments"><a class="markdownIt-Anchor" href="#5-experiments"></a> 5. Experiments</h1><p><img src="/2020/03/06/atom/13.jpg" alt></p><p><img src="/2020/03/06/atom/14.jpg" alt></p><p><img src="/2020/03/06/atom/15.jpg" alt></p><p><img src="/2020/03/06/atom/16.jpg" alt></p><p><img src="/2020/03/06/atom/17.jpg" alt></p><h1 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h1><ul><li><a href="https://blog.csdn.net/PNAN222/article/details/91049022">Pytracking代码运行笔记</a></li><li><a href="https://blog.csdn.net/xwmwanjy666/article/details/9775784">ATOM: Accurate Tracking by Overlap Maximization</a></li><li><a href="https://zhuanlan.zhihu.com/p/79355209">ATOM: Accurate Tracking by Overlap Maximization论文笔记</a></li><li><a href="https://www.cnblogs.com/wangxiaocvpr/p/10520522.html">论文笔记：ATOM: Accurate Tracking by Overlap Maximization</a></li><li><a href="https://zh.gluon.ai/chapter_convolutional-neural-networks/resnet.html">残差网络（ResNet）</a></li><li><a href="https://blog.csdn.net/qq547276542/article/details/78186050">共轭梯度法的推导与完整算法</a></li></ul><h1 id="7-代码解析无法运行"><a class="markdownIt-Anchor" href="#7-代码解析无法运行"></a> 7. 代码解析【无法运行】</h1><p>启动visdom：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m visdom.server</span><br></pre></td></tr></table></figure><p>编译prroi_pooling：</p><p>【失败】</p><p>找不到模块</p><h1 id="8-补充结合iou-net"><a class="markdownIt-Anchor" href="#8-补充结合iou-net"></a> 8. 补充【结合IoU-Net】</h1><p>追踪问题和目标检测问题的区别：</p><ul><li><p>追踪针对的目标类别是未知的，而检测问题是依赖于每个类别上的检测。</p><blockquote><p>论文说原有的IoU-Net是class-specific的，原因就在于此。</p></blockquote></li></ul><p>​但仍需要class-specific IoU predictor来对每一帧进行分析得到high-level nature。因为这个训练过程太费时，故而采用offline training来学习general representation用于IoU predictor。</p><p>​论文中的Fig.3就是实现了类似IoU-Net的功能，只不过是融合了reference的信息，最后输出的就是IoU分数。</p><blockquote><p>问题：该部分的输入（各种框）从哪里来？</p></blockquote><p><img src="/2020/03/06/atom/20190731160156261.png" alt="整体架构"></p><p><img src="/2020/03/06/atom/8.jpg" alt></p><p>​而online的部分就是负责区分background distractors，增强追踪的鲁棒性。我理解应该是两个语义比较接近的target，比如行人追踪中，其他的行人就可以理解为干扰对象。</p>]]></content>
      
      
      <categories>
          
          <category> IoU-Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoU-Net </tag>
            
            <tag> PrRoI Pooling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IoU-Net</title>
      <link href="/2020/03/02/iou-net/"/>
      <url>/2020/03/02/iou-net/</url>
      
        <content type="html"><![CDATA[<h1 id="acquisition-of-localization-confidence-for-accurate-object-detectioniou-net"><a class="markdownIt-Anchor" href="#acquisition-of-localization-confidence-for-accurate-object-detectioniou-net"></a> Acquisition of Localization Confidence for Accurate Object Detection（IoU-Net）</h1><blockquote><p>Borui Jiang*, Ruixuan Luo*, Jiayuan Mao*, Tete Xiao, Yuning Jiang* (* indicates equal contribution.)</p></blockquote><p>paper：<a href="https://arxiv.org/abs/1807.11590">https://arxiv.org/abs/1807.11590</a></p><p>code：<a href="https://github.com/vacancy/PreciseRoIPooling">https://github.com/vacancy/PreciseRoIPooling</a></p><a id="more"></a><h1 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h1><h2 id="11-传统方法"><a class="markdownIt-Anchor" href="#11-传统方法"></a> 1.1 传统方法</h2><p>​现阶段的two-stage目标检测器主要是解决multi-task learning problem：</p><ol><li>distinguish foreground object proposals from  background and assign them with proper class labels.</li><li>regress a set of coefficients which localize the object by maximizing intersection-over-union (IoU) or other metrics between detection results and the ground-truth.</li></ol><p>任务流程：</p><ol><li>RPN找出一系列候选框，区分前景背景。</li><li>对前景框进行分类和回归，得到每个框的分类置信度及回归坐标。</li><li>通过NMS，以分类置信度排序，过滤掉IoU大于一定阈值的框，得到最终的结果 。</li></ol><blockquote><p>例如FRCNN：</p><p>​并行输出两个任务：cls score + bbox offset，调整好bbox位置，再做NMS剔除冗余bbox。</p></blockquote><p>传统的NMS：</p><ul><li><p>classification confidence（有）</p><p>给每个proposal打class label，最后使用bbox regression来找到最符合GT的位置，最后，通过NMS消除冗余的bbox。</p></li><li><p>localization confidence（无）</p></li></ul><h3 id="111-传统方法缺陷"><a class="markdownIt-Anchor" href="#111-传统方法缺陷"></a> 1.1.1 传统方法缺陷</h3><p>由此带来的缺点：</p><ol><li>只用classification confidence作为metric for ranking the proposals。而忽略了localization accuracy，会导致IoU更大但cls score更小的框在NMS中被抑制。</li></ol><p><img src="/2020/03/02/iou-net/1.jpg" alt></p><blockquote><p>“bad money drives out good”</p></blockquote><p>​ the misalignment between classification confidence and localization accuracy may lead to accurately localized bounding boxes being suppressed by less accurate ones in the NMS procedure.</p><ol start="2"><li>缺乏localization confidence使bbox regression解释性变差；而且多次运用bbox reg会使bbox定位精度下降。</li></ol><p><img src="/2020/03/02/iou-net/2.jpg" alt></p><blockquote><p>non-monotonicity of iterative bounding box regression（非单调性）</p></blockquote><p>​That is, bounding box regression may degenerate the  localization of input bounding boxes if applied for multiple times.</p><h2 id="12-iou-net"><a class="markdownIt-Anchor" href="#12-iou-net"></a> 1.2 IoU-Net</h2><p>​IoU-Net使用待检测bbox和ground-truth box的IoU作为 localization criterion，可以解决前面提到的问题。</p><ol><li><p><mark>IoU-guided NMS</mark></p><p>​IoU是一个natural criterion for localization accuracy，使用predicted IoU作为ranking keyword in NMS</p></li><li><p><mark>Precise RoI Pooling</mark></p><p>​使用optimization-based bounding box refinement procedure替代原有的 traditional regression-based method，使用predicted IoU作为optimization objective，对于localization confidence也有很好的解释性；并且提供一个monotonic improvement。</p><p>​PrRoI Pooling layer使用梯度上升法解决IoU优化问题。</p></li></ol><h1 id="2-object-localization"><a class="markdownIt-Anchor" href="#2-object-localization"></a> 2. Object Localization</h1><p>​A standard <strong>FPN</strong> detector is trained on <strong>MS-COCO</strong><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>v</mi><mi>a</mi><mi>l</mi><mn>35</mn><mi>k</mi></mrow><annotation encoding="application/x-tex">trainval35k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord">3</span><span class="mord">5</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> as the <mark>baseline</mark> and tested on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">minival</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> for the study.</p><h2 id="21-misalignment-between-classification-confidence-and-localization-accuracy1"><a class="markdownIt-Anchor" href="#21-misalignment-between-classification-confidence-and-localization-accuracy1"></a> 2.1  misalignment between classification confidence and localization accuracy【1】</h2><h3 id="211-nms方法和一些改进"><a class="markdownIt-Anchor" href="#211-nms方法和一些改进"></a> 2.1.1 NMS方法和一些改进</h3><p><strong>[parameter free]</strong></p><ul><li><p>NMS：找到最大分类置信度的框，并把邻近的与该框重合大与predefined overlapping threshold值的框进行消除。</p></li><li><p>Soft-NMS：把NMS中的消除换成了降低置信度，leading to a higher recall。</p></li></ul><p><strong>[parameter-based methods]</strong>（需要更多计算力）</p><ul><li><p>Learning-based Algorithm：计算所有bbox的overlap矩阵，使用AP聚类进行选择。</p></li><li><p>GossipNet：后处理网络，基于bbox和cls confidence训练，替代NMS。</p></li><li><p>End-to-end network：使用端到端网络学习detected bbox之间的关系。</p></li></ul><h3 id="212-分析"><a class="markdownIt-Anchor" href="#212-分析"></a> 2.1.2  分析</h3><h4 id="2121-分布可视化"><a class="markdownIt-Anchor" href="#2121-分布可视化"></a> 2.1.2.1 分布可视化</h4><p>​在NMS步骤前，classification confidence和localization confidence在所有bbox中的分布可视化图如下：</p><p><img src="/2020/03/02/iou-net/3.jpg" alt></p><blockquote><p>x坐标表示detected box和ground-truth之间的IoU，y坐标表示其类别置信度。</p></blockquote><p>​通过分析Pearson correlation coefficient（皮尔逊相关系数，衡量线性相关程度），我们可以认为localization accuracy和分类置信度没有很大的相关性。</p><p>​上述情况产生的原因为：</p><p>​很多基于CNN的检测器在区分前景和背景时，如果检测到的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>o</mi><msub><mi>x</mi><mrow><mi>d</mi><mi>e</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">box_{det}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与ground-truth之一的IoU &gt; 阈值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Ω</mi><mrow><mi>t</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Omega_{train}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord">Ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，则认为是正例。言下之意即，如果IoU大与一定阈值的box就全部弄进来的话，会降低bbox定位的准确性。</p><p>​比如下图中分类置信度大但定位不太准确的红色框：</p><p><img src="/2020/03/02/iou-net/1.jpg" alt></p><h4 id="2122-nms-iou-guided-nms-no-nms"><a class="markdownIt-Anchor" href="#2122-nms-iou-guided-nms-no-nms"></a> 2.1.2.2 NMS / IoU-Guided NMS / No-NMS</h4><p><img src="/2020/03/02/iou-net/4.jpg" alt></p><blockquote><p>问题：为什么NMS和IoU-Guided NMS在0.5/0.6/0.7的时候产生的boxes比No-NMS的还多？</p><p>是否是因为在RPN中做的NMS，本身的anchor box就已经超出ground-truth很多了？</p><p><img src="/2020/03/02/iou-net/75922-20180306113548668-1747435774.jpg" alt="img"></p></blockquote><blockquote><p>问题：文章中的Repulsion Loss是指的什么？</p></blockquote><h2 id="22-non-monotonic-bounding-box-regression2"><a class="markdownIt-Anchor" href="#22-non-monotonic-bounding-box-regression2"></a> 2.2 Non-monotonic bounding box regression【2】</h2><p>​<em>Cai, Z., Vasconcelos, N.: Cascade r-cnn: Delving into high quality object detection. arXiv preprint arXiv:1712.00726 (2017)</em> 中提出应用bbox reg超过两次并不能带来显著提升，其原因是多步bbox reg产生了distribution mismatch，可以通过重采样策略解决这个问题。</p><p>​迭代bbox reg的性能如下图：</p><p><img src="/2020/03/02/iou-net/5.jpg" alt></p><h1 id="3-iou-net"><a class="markdownIt-Anchor" href="#3-iou-net"></a> 3. IoU-Net</h1><p><img src="/2020/03/02/iou-net/6.jpg" alt></p><p>​IoU predictor从FPN提取视觉特征并且对每个bbox估计localization accuracy（IoU）。</p><blockquote><p>问题：<strong>class-aware</strong> IoU predictors是什么意思？</p><p>+cls score //</p></blockquote><h2 id="31-iou-predictor"><a class="markdownIt-Anchor" href="#31-iou-predictor"></a> 3.1 IoU predictor</h2><p>​本文IoU预测器的输入不是用RPN产生的RoIs，而是对Ground Truth框随机扰动，得到Jittered RoIs，过滤掉与GT的IoU&lt;0.5的框，剩下的作为输入，经过PrRoI Pooling给IoU predictor。</p><h2 id="32-iou-guided-nms"><a class="markdownIt-Anchor" href="#32-iou-guided-nms"></a> 3.2 IoU-guided NMS</h2><p>​本文通过IoU-guided NMS来解决misalignment between classification confidence and localization accuracy问题。</p><p><img src="/2020/03/02/iou-net/7.jpg" alt></p><blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">S</mi></mrow><annotation encoding="application/x-tex">\mathcal{S}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.075em;">S</span></span></span></span></span>：classification confidence</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">I</mi></mrow><annotation encoding="application/x-tex">\mathcal{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.07382em;">I</span></span></span></span></span>：localization confidence（IoU）</p></blockquote><h2 id="33-bbox-refinement-as-an-optimization-procedure"><a class="markdownIt-Anchor" href="#33-bbox-refinement-as-an-optimization-procedure"></a> 3.3 bbox refinement as an optimization procedure</h2><p><img src="/2020/03/02/iou-net/8.jpg" alt></p><blockquote><p>比如在Fast RCNN框架中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>r</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">crit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 是用smooth-L1距离。<br>用回归的方式估计<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">c^{*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span></span></span></span>，得到的结果受输入分布影响大，而且如Cascade RCNN指出，回归次数增加，效果会越来越差。</p></blockquote><p>​传统的Regression-based algorithms使用前馈网络直接估计最优解<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>c</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">c^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>，然而该方法对于输入的分布不鲁棒，可能会导致monotonic localization improvement。</p><p>​本文提出optimization-based bbox refinement method，使用IoU-Net作为鲁棒的localization accuracy（IoU）estimator，更进一步地，IoU estimator还可以用作early-stop condition。</p><p><img src="/2020/03/02/iou-net/9.jpg" alt></p><p><img src="/2020/03/02/iou-net/10.jpg" alt></p><p><strong>算法流程：</strong></p><p>for <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> =1 to T (最大迭代次数) :</p><ul><li>迭代输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">b_j \in B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span> (检测出的所有bbox)<ul><li>用PrPool来抽 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_{j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 特征，然后通过IoU分支得到梯度grad，以及分数PrevScore，</li><li>通过反向传播，更新 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></li><li>用新的 $ b_j$ 计算出新的分数NewScore</li><li>如果更新前后分数变化小于阈值，则将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>b</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">b_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>标记，存入A中，不进入下一次迭代</li></ul></li><li>直到B中所有bbox被存入A中，或者迭代到一定次数T才终止迭代</li></ul><h1 id="4-roi-pooling-roi-align-prroi-pooling"><a class="markdownIt-Anchor" href="#4-roi-pooling-roi-align-prroi-pooling"></a> 4. RoI Pooling / RoI Align / PrRoI Pooling</h1><h2 id="41-roi-pooling-以faster-rcnn为例"><a class="markdownIt-Anchor" href="#41-roi-pooling-以faster-rcnn为例"></a> 4.1 RoI Pooling 【以Faster RCNN为例】</h2><p><img src="/2020/03/02/iou-net/12.jpg" alt></p><h3 id="411-输入"><a class="markdownIt-Anchor" href="#411-输入"></a> 4.1.1 输入</h3><ol><li><p>特征图（feature map）：</p><p>​在Faster RCNN中，它是与RPN共享那个特征图，通常我们称之为“share_conv”。</p></li><li><p>RoIs：</p><p>​在Fast RCNN中，指的是Selective Search的输出；在Faster RCNN中指的是RPN的输出，一堆矩形候选框，形状为1x5x1x1（4个坐标+索引index）。</p><blockquote><p>问题：为什么形状是1x5x1x1 ？包含哪些数据？</p></blockquote><p>​其中值得注意的是：坐标的参考系不是针对feature map这张图的，而是<strong>针对原图</strong>的（神经网络最开始的输入）。</p></li></ol><h3 id="412-输出"><a class="markdownIt-Anchor" href="#412-输出"></a> 4.1.2 输出</h3><p>​输出是batch个vector，其中batch的值等于RoI的个数，vector的大小为channel * w * h；RoI Pooling的过程就是将一个个大小不同的box矩形框，都映射成大小固定（w * h）的矩形框。</p><h3 id="413-细节"><a class="markdownIt-Anchor" href="#413-细节"></a> 4.1.3 细节</h3><p><img src="/2020/03/02/iou-net/13.jpg" alt></p><p><img src="/2020/03/02/iou-net/14.jpg" alt></p><p>两次量化过程：</p><p>(1)、在原图上生成的region proposal 映射到feature map需要除以16或者32的时候，边界出现小数，这是第一次量化。</p><p>(2)、在每个roi里划分成k×k(7×7)的bins，对每个bin中均匀选取多少个采样点，然后进行max pooling，也会出现小数，这是第二次量化。</p><p><img src="/2020/03/02/iou-net/15.gif" alt></p><h3 id="414-反向传播"><a class="markdownIt-Anchor" href="#414-反向传播"></a> 4.1.4 反向传播</h3><blockquote><p>思考：RoI Pooling不能检测小物体</p><p>​因为bbox最后都统一为了7*7的大小，所以若待检的物体比较小的话（即初始框比较小），则会导致无法检测到。</p></blockquote><blockquote><p>待理解：RoI Pooling怎么进行反向传播？</p><p>见 <a href="https://zhuanlan.zhihu.com/p/59692298">你真的学会RoI Pooling了吗?</a></p></blockquote><p><img src="/2020/03/02/iou-net/equation.svg" alt="img"></p><p>​这里，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 代表池化前特征图上的像素点；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>r</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{rj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 代表池化后的第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>个候选区域的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 个点；$i^*(r,j) $代表点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>r</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{rj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 像素值的来源（最大池化的时候选出的最大像素值所在点的坐标）。由上式可以看出，只有当池化后某一个点的像素值在池化过程中采用了当前点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的像素值（即满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><msup><mi>i</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>r</mi><mi mathvariant="normal">，</mi><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i=i^*(r，j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>），才在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 处回传梯度。</p><p>![img]<code>(/</code>v2-e78fcd1ea642bfad66ec37b4e3e3c7ca_r.jpg)</p><h2 id="42-roi-align以mask-rcnn为例"><a class="markdownIt-Anchor" href="#42-roi-align以mask-rcnn为例"></a> 4.2 RoI Align【以Mask RCNN为例】</h2><p>​RoI Align是在[Mask RCNN](E:\SHU\optical_flow\papers\visual tracking\Mask R-CNN.pdf)中提出的，不需要对两步量化中产生的浮点数坐标的像素值都进行计算，而是设计了一套优雅的流程。</p><h3 id="421-细节"><a class="markdownIt-Anchor" href="#421-细节"></a> 4.2.1  细节</h3><p><img src="/2020/03/02/iou-net/16.jpg" alt></p><p>​基本步骤和RoI Pooling差不多，只是不对计算得到的浮点数进行量化取整，而是划分到最后小区域之后，在feature map上采样时采取双线性插值法计算。</p><p><img src="/2020/03/02/iou-net/17.jpg" alt></p><p>RoI Align示意图：</p><p>​假定采样点数为4，即表示，对于每个2.97 x 2.97的<strong>bin</strong>，<strong>平分四份小矩形，每一份取其中心点位置，而中心点位置的像素，采用双线性插值法进行计算</strong>，这样就会得到四个小数坐标点的像素值。</p><p><img src="/2020/03/02/iou-net/20.jpg" alt></p><h3 id="422-反向传播"><a class="markdownIt-Anchor" href="#422-反向传播"></a> 4.2.2 反向传播</h3><p>​类比于ROI Pooling，ROI Align的反向传播需要稍作修改。</p><p>​因为在ROIAlign中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i*(r,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>  是一个浮点数的坐标位置(前向传播时计算出来的采样点)，所以在池化前的特征图中，每一个与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i*(r,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 横纵坐标均小于1的点都应该接受与此对应的点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>y</mi><mrow><mi>r</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">y_{rj}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 回传的梯度，故ROI Align 的反向传播公式如下式所示。</p><p><img src="/2020/03/02/iou-net/equation-2.svg" alt="img"></p><p>​ 其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi mathvariant="normal">.</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(.)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord">.</span><span class="mclose">)</span></span></span></span> 表示两点之间的距离，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">\Delta h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault">h</span></span></span></span> 和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\Delta w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>r</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i*(r,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>横纵坐标的差值，这里作为双线性内插的系数乘在原始的梯度上。直观的理解就是离采样点越近的整数坐标点比重越大，极端的例子是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">\Delta h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault">h</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">\Delta w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>都等于0的时候，就是当前采样点的值。</p><blockquote><p>卷积反向传播</p><p>​为了符合梯度计算，我们在误差矩阵周围填充了一圈0，此时我们将卷积核翻转后和反向传播的梯度误差进行卷积，就得到了前一次的梯度误差。</p></blockquote><h3 id="423-双线性插值法图像插值法"><a class="markdownIt-Anchor" href="#423-双线性插值法图像插值法"></a> 4.2.3 双线性插值法（图像插值法）</h3><p>​在图像的放大和缩小的过程中，需要计算新图像像素点在原图的位置，如果计算的位置不是整数，就需要用到图像的内插，我们需要寻找在原图中最近得像素点赋值给新的像素点，这种方法很简单是<strong>最近邻插法，<strong>这种方法好理解、简单，但是不实用，会产生是真现象，产生棋盘格效应，更实用的方法就是</strong>双线性插值法。</strong></p><p><strong>一维线性插值：</strong></p><p><img src="/2020/03/02/iou-net/18.jpg" alt></p><p><strong>双线性插值：</strong></p><p><img src="/2020/03/02/iou-net/19.jpg" alt></p><p>​先对红色点对（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mn>12</mn></msub><mo separator="true">,</mo><msub><mi>Q</mi><mn>22</mn></msub></mrow><annotation encoding="application/x-tex">Q_{12},Q_{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）和（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>Q</mi><mn>11</mn></msub><mo separator="true">,</mo><msub><mi>Q</mi><mn>21</mn></msub></mrow><annotation encoding="application/x-tex">Q_{11},Q_{21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）插值得到蓝色点，再对蓝色点对（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>R</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>R</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">R_1,R_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.00773em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）进行插值得到$ P$ 点的值。</p><h2 id="43-prroi-pooling本文提出"><a class="markdownIt-Anchor" href="#43-prroi-pooling本文提出"></a> 4.3 PrRoI  Pooling【本文提出】</h2><p>​因为RoI Align对于每个bin取出固定的点来做池化，这样对于bin的大小不具有适应性。PrRoI Pooling则使用二阶积分来做池化，可以避免量化。</p><p>​<mark>通过双线性插值，可以将feature map看成关于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>连续的函数</mark>，表达式为：</p><p><img src="/2020/03/02/iou-net/22.jpg" alt></p><p><img src="/2020/03/02/iou-net/23.jpg" alt></p><p>​其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>C</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">IC(x,y,i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>是插值系数，把RoI看成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>i</mi><mi>n</mi><mo>=</mo><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">bin={(x_1,y_1),(x_2,y_2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是左上角的像素点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是右下角的像素点。从特征图feature map和bin中进行polling采样可以用二阶积分来计算，即上式（3）。</p><p><img src="/2020/03/02/iou-net/24.jpg" alt></p><p>​由于PrRoI Pooling在前向传播时是连续可导的，其反向传播也是连续可导的，避免了任何量化。</p><p><img src="/2020/03/02/iou-net/29.jpg" alt></p><h2 id="44-三种方法对比"><a class="markdownIt-Anchor" href="#44-三种方法对比"></a> 4.4 三种方法对比</h2><p>​与RoI Pooling / RoI Align的对比图如下所示：</p><p><img src="/2020/03/02/iou-net/21.jpg" alt></p><p>​传统的RoI Pooling，需要进行两次量化；</p><p>​RoI Aling则在bin中通过双线性插值进行N=4的采样（即只采样四个点作为bin的代表），其中N是预定义的，不能自适应bin的大小；</p><p>​而本文提出的PrRoI Pooling把整个区域看做连续的，对于bin中白色的区域，都可以用双线性插值通过绿色的已知值得到，从而可以在连续的特征图上直接计算二阶积分，效果更好，更精确。</p><h1 id="5-总结experiments"><a class="markdownIt-Anchor" href="#5-总结experiments"></a> 5. 总结+Experiments</h1><p><img src="/2020/03/02/iou-net/30.jpg" alt></p><p><img src="/2020/03/02/iou-net/75922-20180306111851933-70273855.png" alt></p><ul><li>IoU-Guided NMS</li><li>bbox refinement as an optimization procedure (PrRoI Pooling)</li></ul><p><img src="/2020/03/02/iou-net/25.jpg" alt></p><p><img src="/2020/03/02/iou-net/26.jpg" alt></p><p><img src="/2020/03/02/iou-net/27.jpg" alt></p><p><img src="/2020/03/02/iou-net/28.jpg" alt></p><blockquote><p>速度开销不大，在可接受的范围内。</p></blockquote><p>文中对**<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><msub><mi>P</mi><mn>50</mn></msub></mrow><annotation encoding="application/x-tex">AP_{50}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>结果较差**的原因也做了分析：</p><p>​我们主要将表3中AP50的较差结果归因于IoU估计误差。当边界框的真实IoU较低时，它们的外观差异就更⼤。如图2（b）所示，对于IoU较低的盒⼦，IoU估计变得不太准确。这降低了下游细化和抑制的性能。我们凭经验发现，可以通过诸如在训练过程中以较低的IoU采样更多边界框之类的技术来部分解决此问题。</p><h1 id="6-参考资料"><a class="markdownIt-Anchor" href="#6-参考资料"></a> 6. 参考资料</h1><ul><li>ROI Pooling原理及实现 <a href="https://blog.csdn.net/u011436429/article/details/80279536">https://blog.csdn.net/u011436429/article/details/80279536</a></li><li>论文笔记：(IOU-Net) Acquisition of Localization Confidence for Accurate Object Detection【翻译】<a href="https://blog.csdn.net/ctfabc4425/article/details/81490805">https://blog.csdn.net/ctfabc4425/article/details/81490805</a></li><li>IoUNet(2)_总结_ECCV2018 <a href="https://zhuanlan.zhihu.com/p/45518623">https://zhuanlan.zhihu.com/p/45518623</a></li><li>你真的学会RoI Pooling了吗? <a href="https://zhuanlan.zhihu.com/p/59692298">https://zhuanlan.zhihu.com/p/59692298</a></li><li>RoIPooling与RoIAlign的区别 <a href="https://blog.csdn.net/kk123k/article/details/86563425">https://blog.csdn.net/kk123k/article/details/86563425</a></li><li>ROI Pooling层解析 <a href="https://blog.csdn.net/a8039974/article/details/80811699">https://blog.csdn.net/a8039974/article/details/80811699</a></li><li>Precise RoI Pooling（PrRoI Pooling）笔记 <a href="https://blog.csdn.net/discoverer100/article/details/90519423">https://blog.csdn.net/discoverer100/article/details/90519423</a></li><li>ROI Pooling原理及实现 <a href="https://blog.csdn.net/u011436429/article/details/80279536">https://blog.csdn.net/u011436429/article/details/80279536</a></li><li>Faster R-CNN——RPN网络+ROI池化 (目标检测)(two-stage)(深度学习)(NIPS 2015)  <a href="https://blog.csdn.net/Gentleman_Qin/article/details/84403147">https://blog.csdn.net/Gentleman_Qin/article/details/84403147</a></li><li>随笔分类 - Faster-RCNN  <a href="https://www.cnblogs.com/wind-chaser/category/1526706.html">https://www.cnblogs.com/wind-chaser/category/1526706.html</a></li><li>【代码阅读】Faster RCNN 网络结构详解  <a href="https://blog.csdn.net/wqwqqwqw1231/article/details/100823263">https://blog.csdn.net/wqwqqwqw1231/article/details/100823263</a></li></ul><h1 id="7-代码解析"><a class="markdownIt-Anchor" href="#7-代码解析"></a> 7. 代码解析</h1><p>文件中的代码已经过时，需要更改为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from jactorch.utils.unittest import TorchTestCase</span></span><br><span class="line"><span class="keyword">from</span> torchtestcase <span class="keyword">import</span> TorchTestCase</span><br></pre></td></tr></table></figure><p>安装ninja</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/ninja-build/ninja.git &amp;&amp; cd ninja</span><br><span class="line">git checkout release</span><br></pre></td></tr></table></figure><p>打开，进入ninja目录，输入命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python configure.py --bootstrap</span><br></pre></td></tr></table></figure><p>开始编译，成功后会在当前目录下生成ninja.exe（windows下），把该文件拷贝到系统目录C:/Windows/System32完成安装。</p><p>测试是否安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./ninja ninja_test</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./ninja_test</span></span><br><span class="line">[214/226] SubprocessTest.SetWithLotsRaise [ulimit -n] above 1025 (currently 1024) to make this test go</span><br><span class="line">[226/226] ElideMiddle.ElideInTheMiddle</span><br><span class="line">passed</span><br></pre></td></tr></table></figure><p>运行出错：</p>]]></content>
      
      
      <categories>
          
          <category> IoU-Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoU-Net </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
